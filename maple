#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my $version_num = "0.1.3"; 

# Begin tracking information for postscript output legend
my $ps_info = $version_num;

my $usage = "maple version $version_num
Usage: maple [options] [butter_alignment.bam] [genome.fasta] [chr:start-stop] [strand 'plus' or 'minus']

Dependencies: 
samtools
RNAfold
RNAplot

Options:

--locus_name [string] : name of locus [optional .. if not given, defaults to UserLocus]
--mature [string] : annotated/hypothesized mature miRNA sequence [optional]
--mature_name [string] : name of mature query [optional .. if --mature is given, but --mature_name is not, defaults to UserMature]
--show_duplexes [string] : What types of miR/miR* duplexes to show details for. 'all', 'pass', or 'none'. Default: 'pass' 
--miRType [string] : Kingdom from which your putative MIRNA locus hails. 'animal' or 'plant'. Defaults to 'plant'
--no_ps : Suppress creation of post-script image file
--help : print this message and quit
--version : print version and quit

Documentation: perldoc maple
";

# If no arguments, print help and quit
unless($ARGV[0]) {
    print "$usage";
    exit;
}

# Initialize options
my $mature = '';
my $help = '';
my $version = '';
my $mature_name = 'UserMature';
my $show_duplexes = 'pass';
my $no_ps;
my $locus_name = 'UserLocus';
my $miRType = 'plant';

# Get ye options
GetOptions ('mature=s' => \$mature,
	    'mature_name=s' => \$mature_name,
	    'help' => \$help,
	    'show_duplexes=s' => \$show_duplexes,
	    'no_ps' => \$no_ps,
	    'locus_name=s' => \$locus_name,
	    'miRType=s' => \$miRType,
	    'version' => \$version);

# If version or help, act accordingly
if($version) {
    print "maple version $version_num\n";
    exit;
}
if($help) {
    print "$usage";
    exit;
}

# Check for required samtools installation
(open(SAMCHECK, "which samtools |")) || die "\nAbort: Failed to check for samtools installation\n";
my $samcheck = <SAMCHECK>;
chomp $samcheck;
close SAMCHECK;
unless ($samcheck =~ /samtools$/) {
    die "\nAbort: samtools installation not found. Please install samtools to your PATH and try again\n";
}

# Check for required RNAfold installation
(open(RNACHECK, "which RNAfold |")) || die "\nAbort: Failed to check for RNAfold installation\n";
my $rnacheck = <RNACHECK>;
chomp $rnacheck;
close RNACHECK;
unless( $rnacheck =~ /RNAfold$/) {
    die "\nAbort: RNAfold installation not found. Please install RNAfold to your PATH and try again\n";
}

# Check for required RNAplot installation
(open(RNACHECK, "which RNAplot |")) || die "\nAbort: Failed to check for RNAplot installation\n";
$rnacheck = <RNACHECK>;
chomp $rnacheck;
close RNACHECK;
unless( $rnacheck =~ /RNAplot$/) {
    die "\nAbort: RNAplot installation not found. Please install RNAplot to your PATH and try again\n";
}


# Validate option --strand
my $cl_strand = $ARGV[-1];
unless(($cl_strand eq "plus") or ($cl_strand eq "minus")) {
    die "\nAbort: Strand is invalid. Must be either \'plus\', or \'minus\'.\n";
}
my $strand;
if($cl_strand eq "plus") {
    $strand = "+";
} else {
    $strand = "-";
}

# Validate option --mature
my $mature_ok;
if($mature) {
    # upppercase
    $mature_ok = uc $mature;
    # change T to U
    $mature_ok =~ s/T/U/g;
    # Verify
    unless($mature_ok =~ /^[AUCG]+$/) {
	die "\nAbort: Option --mature is invalid. It must be a string containing only AUTGCautgc characters.\n";
    }
}

# Validate option --show_duplexes
unless(($show_duplexes eq "all") or 
       ($show_duplexes eq "pass") or
       ($show_duplexes eq "none")) {
    die "Invalid value for option --show_duplexes. Must be all, pass, or none\n";
}

# Validate option --miRType
unless(($miRType eq "plant") or ($miRType eq "animal")) {
    die "Invalid value for option --miRType. Must be \'animal\' or \'plant\'\n";
}

# Validate genome and get faidx
my $genomefile;
if($ARGV[-3]) {
    if(-r $ARGV[-3]) {
	$genomefile = $ARGV[-3];
    } else {
	die "Genome file $ARGV[-3] was not readable. Abort.\n";
    }
} else {
    die "Genome file was not found in command line. Abort.\n";
}
my $expected_faidx = "$genomefile" . "\.fai";
unless(-r $expected_faidx) {
    print STDERR "\nAttempting to create  required genome index file $expected_faidx using samtools ..";
    system "samtools faidx $genomefile";
    if(-r $expected_faidx) {
	print STDERR " Done\n";
    } else {
	print STDERR " Failed! Abort\n";
	exit;
    }
}
# strip file path info for use in postscript legend
my $g_strip = $genomefile;
$g_strip =~ s/^.*\///g;
$ps_info .= "\n$g_strip";


# Validate bam
my $bamfile;
my $bam_check;
if($ARGV[-4]) {
    if($ARGV[-4] =~ /\.bam$/) {
	if(-r $ARGV[-4]) {
	    $bamfile = $ARGV[-4];
	    $bam_check = validate_bam($bamfile,$expected_faidx);
	    unless($bam_check) {
		exit;
	    }
	} else {
	    die "Abort: bamfile $ARGV[-4] was not readable\n";
	}
    } else {
	die "Abort: bamfile $ARGV[-4] did not end in .bam\n";
    }
} else {
    die "Abort: No bamfile was specified on the command line\n";
}
# strip file path info for use in postscript legend
my $b_strip = $bamfile;
$b_strip =~ s/^.*\///g;
$ps_info .= "\n$b_strip";



# Validate coordinates
my $co;
if($ARGV[-2]) {
    $co = $ARGV[-2];
} else {
    die "Abort: Coordinates not found on the command line\n";
}
my $co_check = check_coordinates ($co,$expected_faidx);
unless($co_check) {
    exit;
}
## $ps_info .= "\n$co";  ## need to have the modified, trimmed down location stored, not the user's input, which might end up being trimmed
$ps_info .= "\n$strand";
$ps_info .= "\n$locus_name";

# Get the sense strand sequence
my $sense_seq = get_sense_seq($genomefile,$co);


# Get the rev comp, unless --strand was "+"
my $revcomp_seq;
unless($strand eq "+") {
    $revcomp_seq = reverse $sense_seq;
    $revcomp_seq =~ tr/AUGC/UACG/;
}

# Initial information for user
print "\nmaple version $version_num\n";
print "Date: ";
print `date`;
print "Hostname: ";
print `hostname`;
print "Working Directory: ";
print `pwd`;
print "\nAlignments: $ARGV[-4]\n";
print "Genome: $ARGV[-3]\n";
print "Locus: $ARGV[-2]\n";
print "Strand: $strand\n";
print "miRType: $miRType\n";
print "Locus Name: $locus_name\n";
print "User-supplied mature miRNA: ";
if($mature) {
    print "$mature\n";
} else {
    print "Not provided\n";
}
if($mature) {
    print "Mature Name: $mature_name\n";
}
print "Show duplexes: $show_duplexes\n";
print "\n";

if($strand eq "+") {
    master($sense_seq,$bamfile,$mature_ok,$co,"+",$mature_name,$show_duplexes,$ps_info,$miRType);
} elsif($strand eq "-") {
    master($revcomp_seq,$bamfile,$mature_ok,$co,"-",$mature_name,$show_duplexes,$ps_info,$miRType);
}

################

sub master {
    my($seq,$bamfile,$mature,$query,$strand,$name,$show_duplexes,$ps_info,$miRType) = @_;
    
    ## Step one, get a structure
    my $struc_results_alpha = get_struc($seq);
    ## $struc_results is either 0 for no struc found, or tab-delimited brax, trimmed seq, and local start (one-based)
    
    ## Check if the structure is overall totally bogus. miRType affects this
    my $struc_results = check_struc($struc_results_alpha,$miRType);
    
    # only proceed if a structure of some sort was returned
    if($struc_results) {
	# Parse the coordinates of the structure
	my $mod_query = get_mod_query($struc_results,$query,$strand);
	$ps_info .= "\n$mod_query";
	
	
        # Get info for all reads that are fully aligned in the query region on designated strand
	my @sam = get_sam($bamfile,$mod_query,$strand);
	
        ## If no reads at all, do not proceed.
	if($sam[0]) {
	    
            # Compress into hash.  Keys are 1-based starts, relative to mod_query _ length_medianXX_consensusXY_medianXZ, values are frequencies
	    my %read_hash = get_read_hash(\@sam,\$mod_query,\$strand);
	    
            # Get a depth hash .. keys are one-based positions, values are total depths
	    my %depth_hash = get_depth_hash(\%read_hash);
	    
	    # Rearrange data into all possible miR/miR* duplexes
	    my %duplex_hash = get_duplex_hash(\%read_hash,\$struc_results);  # keys: relativestart_length_medianXX_consensusXY_medianXZ_freq, values: same, except for star

	    
	    # Gather score components that can be pre-analyzed and are universal
	    # e1: total alignments .. 0-4 is 0, 5-9 is 0.25, 10-49 is 0.5, 50-99 is 0.75, >= 100 is 1 .. NO Fatals
	    my($all_reads,$uniques) = check_counts(@sam);
	    my $e1;
	    if($all_reads < 5) {
		$e1 = 0;
	    } elsif ($all_reads < 10) {
		$e1 = 0.25;
	    } elsif ($all_reads < 50) {
		$e1 = 0.5;
	    } elsif ($all_reads < 100) {
		$e1 = 0.75;
	    } else {
		$e1 = 1;
	    }
	    
	    # e2: uniquely mapped reads .. 0 for 0, 1 for 1 or more .. NO Fatals
	    my $e2;
	    if($uniques) {
		$e2 = 1;
	    } else {
		$e2 = 0;
	    }
	    
	    # Score each component that is specific to given miR/miR* components.
	    # First, sort .. will end up sorted 5'-3' relative to the putative miRNA locations
	    my @dh_k_sort = sort (keys %duplex_hash);
	    
	    my %provisional = ();  ## a subset of duplex_hash where the partners are valid, except for the pending overall precision check
	    my %failed = ();  ## the other subset of duplex_hash
	    foreach my $mir (@dh_k_sort) {
		my $star = $duplex_hash{$mir};
		my $sd = score_duplex($mir,$star,$struc_results,$miRType);  ## e3, e4, e5, s1, s2, s3, s4, s5, arm, verdict ... tab-delimited
		# glom on the locus-wide ones
		$sd = "$e1\t$e2\t" . "$sd";
		# glom on the star info
		$sd = "$star\t" . "$sd";
		
		# add to the appropriate hash
		if($sd =~ /PASS/) {
		    $provisional{$mir} = $sd;
		    ## test
		    #print "Added $mir $sd to provisional\n";
		} else {
		    $failed{$mir} = $sd;
		    ## test
		    #print "Added $mir $sd to failed\n";
		}
		
	    }
	    
	    my %isomirs = get_isomirs(\%provisional,\%failed);  ## really, isomirs and isomir*'s

	    
	    # Calculate the diversity of the locus .. distinct alignment positions / total number of alignments.
	    my $diversity = get_diversity(\%read_hash);
	    # test
	    #print "\tDiversity: $diversity\n";
	    
	    # Now, simulate the diversity expected under a null model of random processing positions, given the locus length, alignment depth, and sizes of reads...
	    my($sim_div_mean, $sim_div_stdev) = simulate_random_diversity(\%read_hash,\$mod_query);
	    
	    # Simulate diversity expected under an idealized model of a single miRNA and miRNA* only, at ratio of 90% to 10%.
	    my($sim_div_ideal_mean, $sim_div_ideal_stdev) = simulate_ideal_diversity(\@sam);
	    
	    # test
	    #print "\tSimulated random diversity: mean: $sim_div_mean stdev $sim_div_stdev\n";
	    #print "\tSimulated ideal diversity: mean: $sim_div_ideal_mean stdev $sim_div_ideal_stdev\n";
	    
	    # score diversity.
	    my $e6 = score_diversity ($sim_div_mean,$sim_div_stdev,$sim_div_ideal_mean,$sim_div_ideal_stdev,$diversity);
	    
	    
	    final_scoring(\%provisional,\%failed,\$e6); ## modifies the hashes such that keys are offset_length_freq of mirs, values are tab-delimited first entry offset_length_freq of the star, final score, and pass/fail string
	    
	    # report 
	    print "Best Structure at Location $mod_query strand $strand\n";
	    my @sr = split ("\t", $struc_results);

	    # check on user-provided sequence
	    my $mature_prefix = "NULL";
	    if($mature) {
		$mature_prefix = get_mature_prefix($mature,$sr[1]);
		if($mature_prefix eq "NULL") {
		    print "\n\*\*\* WARNING: User-provided mature sequence of $mature did not match in structure location $mod_query strand $strand \*\*\*\n";
		}
	    }

	    print "\n$sr[1]\n$sr[0]\n";
	    # print out all reads in standard cloud format, numbering, and showing basic information (number, and size)
	    my %alt_read_hash = print_read_cloud(\%read_hash,\$sr[1],\$mature_prefix,\$name);  ### $sr[1] is the printed sequence
	    
	    # print simple summary of aligned reads by RNA size
	    print "\nAlignment summary by RNA size:\n";
	    print_align_summary(\%read_hash);
	    
	    # report on all duplexes, in order of score
	    
	    # test
	    #print "provision hash:\n";
	    #while((my $xxx, my $yyy) = each %provisional) {
		#print "key: $xxx value: $yyy\n";
	    #}
	    #exit;
	    
	    # test
	    #print "Failed hash\n";
	    #while((my $xxx, my $yyy) = each %failed) {
		#print "key: $xxx value: $yyy\n";
	    #}
	    #print "Isomir hash\n";
	    #while ((my $ooo, my $ppp) = each %isomirs) {
		#print "key: $ooo value: $ppp\n";
	    #}
	    #exit;

	    
	    report_duplexes(\%provisional,\%failed,\%alt_read_hash,\@sr,\%isomirs,\$mature_prefix,\$name,\$show_duplexes,\$ps_info);
	    
	    # print locus precision
	    print "Observed diversity: $diversity\n";
	    print "Expected diversity under random model: ";
	    # round off this information for display
	    my $round_ran = sprintf("%.3f", $sim_div_mean);
	    my $round_stdev = sprintf("%.3f", $sim_div_stdev);
	    print "$round_ran +\/- $round_stdev\n";
	    my $round_ideal = sprintf("%.3f", $sim_div_ideal_mean);
	    my $round_istdev = sprintf("%.3f", $sim_div_ideal_stdev);
	    print "Expected diversity under idealized MIRNA model: $round_ideal +\/- $round_istdev\n";
	    
	    # create post-script file, highlighting per-nt alignment density
	    unless($no_ps) {
		(open(TEMP, ">temp.txt")) || die "Failure in writing postscript file\n";
		print TEMP "$sr[1]\n$sr[0]\n";
		close TEMP;
		system "RNAplot 2> /dev/null < temp.txt";
		system "rm -f temp.txt";
		# test
		#print "ps_info is\n$ps_info\n";
		#exit;

		my $ps_file = annotate_ps(\%depth_hash,\$ps_info);
		system "rm -f rna.ps";
		print "\nAnnotated post-script file: $ps_file\n";
	    }
	    
	} else {
	    # no alignments found
	    print "\nNo alignments found\!\n";
	    if($mature) {
		print "Query $name verdict: FAIL\n";
		print "Query $name score: 0\n";
	    }
	    print "Locus verdict: FAIL\n";
	    print "Locus score: 0\n";
	    print "Observed diversity: NA\n";
	    print "Expected diversity under random model: NA\n";
	    print "Expected diversity under idealized MIRNA model: NA\n";
	}
    } else {
	# no valid structure found
	print "\nNo Valid structure found\!\n";
	if($mature) {
	    print "Query $name verdict: FAIL\n";
	    print "Query $name score: 0\n";
	}
	print "Locus verdict: FAIL\n";
	print "Locus score: 0\n";
	print "Observed diversity: NA\n";
	print "Expected diversity under random model: NA\n";
	print "Expected diversity under idealized MIRNA model: NA\n";
    }
}

sub check_struc {
    my($alpha,$miRType) = @_;
    unless($alpha) {
	return 0;
    }
    my @alpha_fields = split ("\t", $alpha); ## brax, trimmed seq, local start
    
    my $longest_left;
    my $longest_left_len = 0;
    my $loop_len;
    my $max_loop_len = 0;
    my $temp;
    
    $temp = $alpha_fields[0];
    # find longest helix info
    while($temp =~ /\([\(\.]+\(/g) {
	if((length $&) > $longest_left_len) {
	    $longest_left = $&;
	    $longest_left_len = length $&;
	}
    }
    my $n_paired = 0;
    my $frac_paired;
    my @ll = split ('', $longest_left);
    foreach my $lll (@ll) {
	if($lll eq "\(") {
	    ++$n_paired;
	}
    }
    $frac_paired = $n_paired / $longest_left_len;
    
    # find longest loop
    $temp = $alpha_fields[0];
    while($temp =~ /\(\.+\)/g) {
	$loop_len = (length $&) - 2;
	if($loop_len > $max_loop_len) {
	    $max_loop_len = $loop_len;
	}
    }
    
    # enforce limits
    # frac paired must be at least 0.67 for all miRTypes
    if($frac_paired < 0.67) {
	return 0;
    } elsif ($n_paired < 15) {  ## all have to have at least 15 paired bases
	return 0;
    } else {
	if($miRType eq "plant") {
	    # no more than 150 pairs, and no limit on loop length
	    if($n_paired > 150) {
		return 0;
	    } else {
		return $alpha;
	    }
	} elsif ($miRType eq "animal") {
	    # no more than 45 pairs, and loop length no more than 15
	    if(($n_paired > 45) or ($max_loop_len > 15)) {
		return 0;
	    } else {
		return $alpha;
	    }
	} else {
	    return 0;
	}
    }
}
    
    
    
    

sub score_diversity {
    my($ran_mean,$ran_stdev,$ideal_mean,$ideal_stdev,$observed) = @_;
    # First, the simulated ideal and the simulated randoms must be far enough away from each other .. specifically,
    #  mean_ideal + 2stdev ideal must be less than mean_random - 2stdev random.
    my $ideal_top = (2 * $ideal_stdev) + $ideal_mean;
    my $ran_bot = $ran_mean - (2 * $ran_stdev);
    my $e6;
    if($ideal_top >= $ran_bot) {
	$e6 = 0;
    } else {
	# scale the distance between ideal_mean and ran_mean to 1. closer to ideal_mean is 1, ran_mean is 0
	# boundary conditions first .. within 2 stdevs of either get an absolute score
	if($observed <= $ideal_top) {
	    $e6 = 1;
	} elsif ($observed >= $ran_bot) {
	    $e6 = 0;
	} else {
	    my $x = $ran_bot - $ideal_top;
	    my $y = $observed - $ideal_top;
	    my $z = $y / $x;  ## approaches 0 if very close to ideal, approaches 1 if very close to random
	    $e6 = 1 - $z;
	    
	    # test
	    #print "x: $x y: $y z: $z e6: $e6\n";
	}
    }
    return $e6;
}
	    

sub simulate_ideal_diversity {
    my($sam) = @_; ## by reference, an array
    my $depth = scalar @$sam;
    my @values = ();
    # do 50 simulations
    for(my $j = 1; $j <= 50; ++$j) {
	my $mir = 0;
	my $star = 0;
	for(my $i = 1; $i <= $depth; ++$i) {
	    my $r = rand();
	    if($r < 0.9) {
		++$mir;
	    } else {
		++$star;
	    }
	}
	my $distinct = 0;
	if($mir) {
	    ++$distinct;
	}
	if($star) {
	    ++$distinct;
	}
	my $diversity = $distinct / ($mir + $star);
	push(@values, $diversity);
    }
    my $mean = mean(@values);
    my $stdev = stdev(@values);
    return($mean,$stdev);
}

sub simulate_random_diversity {
    my($read_hash,$locus) = @_;  ## by reference .. hash and scalar
    # do 50 simulations
    my @values = ();
    my $length;
    # parse the locus length
    if($$locus =~ /^\S+:(\d+)-(\d+)/) {
	$length = $2 - $1 + 1;
    } else {
	die "FATAL in sub-routine simulat_random_diveristy .. could not compute locus length from locus $$locus\n";
    }
    my $diversity;
    my $key;
    my $freq;
    my @fields = ();
    my $j;
    my $i;
    my $start;
    my $k;
    my %hits = ();
    my $distinct;
    my $total;
    for(my $j = 1; $j <= 50; ++$j) {
	%hits = ();
	$total = 0;
	while(($key, $freq) = each %$read_hash) {
	    # test
	    #print "for key $key freq $freq\n";
	    @fields = split ("_", $key);
	    # $fields[1] is the read length
	    for($i = 1; $i <= $freq; ++$i) {
		$start = int(rand($length - $fields[1]));
		$k = "$start" . "_" . "$fields[1]";
		++$hits{$k};
		++$total;
		# test
		#print "\twrote $k\n";
	    }
	}
	$distinct = scalar (keys %hits);
	$diversity = $distinct / $total;
	# test
	#print "Wrote diveristy $diversity\n";
	#exit;
	push(@values,$diversity);
    }
    my $mean = mean (@values);
    my $stdev = stdev (@values);
    return ($mean,$stdev);
}

sub mean {
    my(@values) = @_;
    my $n = scalar @values;
    my $sum;
    foreach my $x (@values) {
	$sum += $x;
    }
    my $mean = $sum / $n;
    return $mean;
}

sub stdev {
    my(@values) = @_;
    my $mean = mean(@values);
    my $sum_squares;
    foreach my $x (@values) {
	$sum_squares += ($x - $mean) ** 2;
    }
    my $stdev = sqrt($sum_squares / (scalar @values));
    return $stdev;
}

sub get_mature_prefix {
    my($mature,$seq) = @_; 
    my $length = length $mature;
    my $start;
    while ($seq =~ /$mature/g) {
	$start = (pos $seq) - $length + 1;
    }
    my $prefix;
    if($start) {
	$prefix = "$start" . "_$length";
    } else {
	$prefix = "NULL";
    }
    return $prefix;
}

sub report_duplexes {
    my($passed,$failed,$alt,$sr,$iso,$mature_prefix,$name,$show,$ps_info) = @_;  ## by reference. hash, hash, hash, array, hash, scalar, scalar, scalar, scalar
    my %by_score = ();
    my $best_fail_score = 0;
    my $best_pass_score = 0;
    my $key;
    my $value;
    my $query_verdict = "FAIL";
    my $query_score = 0;
    while(($key, $value) = each %$failed) {
	my @values = split ("\t", $value);
	my $new_key = "$key" . "\t" . "$value";
	my $score = $values[1];
	$by_score{$new_key} = $score;
	if($score > $best_fail_score) {
	    $best_fail_score = $score;
	}
    }
    while(($key, $value) = each %$passed) {
	my @values = split ("\t", $value);
	my $new_key = "$key" . "\t" . "$value";
	my $score = $values[1];
	$by_score{$new_key} = $score;
	if($score > $best_pass_score) {
	    $best_pass_score = $score;
	}
    }
    # determine locus score
    my $locus_score;
    if($best_pass_score > 0) {
	$locus_score = $best_pass_score;
    } else {
	$locus_score = $best_fail_score;
    }
    
    my $locus_verdict = "FAIL"; ## guilty until proven innocent
    
    # sort all entries by score
    my @sorted = sort {$by_score{$b} <=> $by_score{$a}} (keys %by_score);
    my $subseq;
    foreach my $s (@sorted) {
	my @fields = split ("\t", $s);
	my @mir_stuff = split ("_", $fields[0]);
	my @star_stuff = split ("_", $fields[1]);

	my $mir_alt_key = $fields[0];
	$mir_alt_key =~ s/_[^_]+$//g;
	my $star_alt_key = $fields[1];
	$star_alt_key =~ s/_[^_]+$//g;
	
	my $mir_not_found;
	my $star_not_found;

	my $mir_prefix = "$mir_stuff[0]" . "_" . "$mir_stuff[1]";
	my $star_prefix = "$star_stuff[0]" . "_" . "$star_stuff[1]";
	
	if($mir_stuff[-1] == 0) {
	    $mir_not_found = 1;
	}
	if($star_stuff[-1] == 0) {
	    $star_not_found = 1;
	}
	
	my $print_it;
	if($$show eq "all") {
	    $print_it = 1;
	} elsif (($$show eq "pass") and
		 ($fields[-1] =~ /PASS/)) {
	    $print_it = 1;
	}
	
	## which one is 5'-most? .. print that one first
	if((($star_stuff[0] =~ /^\d+$/) and ($mir_stuff[0] < $star_stuff[0])) or
	   ($star_stuff[0] eq "NULL")) {
	    
	    # print miRNA first
	    
	    # seq ids
	    if($print_it) {
		print "\nDuplex: ";
	    }
	    if($mir_not_found) {
		if($print_it) {
		    print "x";
		}
	    } else {
		if($print_it) {
		    print "seq$$alt{$mir_alt_key}";
		}
		if($mir_prefix eq $$mature_prefix) {
		    if($print_it) {
			print " \($$name\)";
		    }
		    $query_verdict = $fields[-1];
		    $query_score = $by_score{$s};
		}
	    }
	    if($print_it) {
		print " \/ ";
	    }
	    if($star_not_found) {
		if($print_it) {
		    print "x\n";
		}
	    } else {
		if($print_it) {
		    print "seq$$alt{$star_alt_key}";
		}
		if($star_prefix eq $$mature_prefix) {
		    if($print_it) {
			print " \($$name\)\n";
		    }
		    $query_verdict = $fields[-1];
		    $query_score = $by_score{$s};
		} else {
		    if($print_it) {
			print "\n";
		    }
		}
	    }
	    
	    # print sequences
	    if($print_it) {
		print "Sequences: ";
		if($mir_not_found) {
		    print "x";
		} else {
		    $subseq = substr($$sr[1], ($mir_stuff[0] - 1), $mir_stuff[1]);
		    print "$subseq";
		}
		print " \/ ";
		if($star_not_found) {
		    print "x\n";
		} else {
		    $subseq = substr($$sr[1], ($star_stuff[0] - 1), $star_stuff[1]);
		    print "$subseq\n";
		}
	    }
	    
	    # print the score
	    if($print_it) {
		print "Score: $by_score{$s}\n";
	    }

            # pass or fail yes or no yes or no yes or no
	    if($print_it) {
		print "Verdict: $fields[-1]\n";
	    }
	    if($fields[-1] =~ /PASS/) {
		$locus_verdict = "PASS";
	    }
	    
	    # print read lengths
	    if($print_it) {
		print "RNA Lengths: ";
		if($mir_not_found) {
		    print "x";
		} else {
		    print "$mir_stuff[1]";
		}
		print " \/ ";
		if($star_not_found) {
		    print "x\n";
		} else {
		    print "$star_stuff[1]\n";
		}
	    }
	    
	    # print number of alignments
	    if($print_it) {
		print "Alignments: $mir_stuff[-1] \/ $star_stuff[-1]\n";
	    }
	    
	    # print multimap tallies
	    if($print_it) {
		print "Median mapping positions \(XX\): ";
		if($mir_not_found) {
		    print "x";
		} else {
		    print "$mir_stuff[2]";
		}
		print " \/ ";
		if($star_not_found) {
		    print "x\n";
		} else {
		    print "$star_stuff[2]\n";
		}
	    }
	    
	    # print alignment probabilities
	    if($print_it) {
		print "Median placement probabilities \(XZ\): ";
		if($mir_not_found) {
		    print "x";
		} else {
		    print "$mir_stuff[4]";
		}
		print " \/ ";
		if($star_not_found) {
		    print "x\n";
		} else {
		    print "$star_stuff[4]\n";
		}
	    }
	    
	    # print isomir status, if a failed duplex
	    if($print_it) {
		unless($fields[-1] =~ /PASS/) {
		    print "Is isomir or isomir\*: ";
		    if($mir_not_found) {
			print "x";
		    } else {
			if(exists($$iso{$fields[0]})) {
			    print "YES";
			} else {
			    print "NO";
			}
		    }
		    print " \/ ";
		    if($star_not_found) {
			print "x\n";
		    } else {
			if(exists($$iso{$fields[1]})) {
			    print "YES\n";
			} else {
			    print "NO\n";
			}
		    }
		}
	    }
	} else {
	    # star is at 5'
	    # seq ids
	    if($print_it) {
		print "\nDuplex: ";
	    }
	    if($star_not_found) {
		if($print_it) {
		    print "x";
		}
	    } else {
		if($print_it) {
		    print "seq$$alt{$star_alt_key}";
		}
		if($star_prefix eq $$mature_prefix) {
		    if($print_it) {
			print " \($$name\)";
		    }
		    $query_verdict = $fields[-1];
		    $query_score = $by_score{$s};
		}
	    }
	    if($print_it) {
		print " \/ ";
	    }
	    if($mir_not_found) {
		if($print_it) {
		    print "x\n";
		}
	    } else {
		if($print_it) {
		    print "seq$$alt{$mir_alt_key}";
		}
		if($mir_prefix eq $$mature_prefix) {
		    if($print_it) {
			print " \($$name\)\n";
		    }
		    $query_verdict = $fields[-1];
		    $query_score = $by_score{$s};
		} else {
		    if($print_it) {
			print "\n";
		    }
		}
	    }
	    
	    # print sequences
	    if($print_it) {
		print "Sequences: ";
		if($star_not_found) {
		    print "x";
		} else {
		    $subseq = substr($$sr[1], ($star_stuff[0] - 1), $star_stuff[1]);
		    print "$subseq";
		}
		print " \/ ";
		if($mir_not_found) {
		    print "x\n";
		} else {
		    $subseq = substr($$sr[1], ($mir_stuff[0] - 1), $mir_stuff[1]);
		    print "$subseq\n";
		}
	    }
	    
	    # print the score
	    if($print_it) {
		print "Score: $by_score{$s}\n";
	    }

            # pass or fail yes or no yes or no yes or no
	    if($print_it) {
		print "Verdict: $fields[-1]\n";
	    }
	    if($fields[-1] =~ /PASS/) {
		$locus_verdict = "PASS";
	    }
	    
	    # print read lengths
	    if($print_it) {
		print "RNA Lengths: ";
		if($star_not_found) {
		    print "x";
		} else {
		    print "$star_stuff[1]";
		}
		print " \/ ";
		if($mir_not_found) {
		    print "x\n";
		} else {
		    print "$mir_stuff[1]\n";
		}
	    }
	    
	    # print number of alignments
	    if($print_it) {
		print "Alignments: $star_stuff[-1] \/ $mir_stuff[-1]\n";
	    }
	    
	    # print multimap tallies
	    if($print_it) {
		print "Median mapping positions \(XX\): ";
		if($star_not_found) {
		    print "x";
		} else {
		    print "$star_stuff[2]";
		}
		print " \/ ";
		if($mir_not_found) {
		    print "x\n";
		} else {
		    print "$mir_stuff[2]\n";
		}
	    }
	    
	    # print alignment probabilities
	    if($print_it) {
		print "Median placement probabilities \(XZ\): ";
		if($star_not_found) {
		    print "x";
		} else {
		    print "$star_stuff[4]";
		}
		print " \/ ";
		if($mir_not_found) {
		    print "x\n";
		} else {
		    print "$mir_stuff[4]\n";
		}
	    }
	    
	    # print isomir status, if a failed duplex
	    if($print_it) {
		unless($fields[-1] =~ /PASS/) {
		    print "Is isomir or isomir\*: ";
		    if($star_not_found) {
			print "x";
		    } else {
			if(exists($$iso{$fields[1]})) {
			    print "YES";
			} else {
			    print "NO";
			}
		    }
		    print " \/ ";
		    if($mir_not_found) {
			print "x\n";
		    } else {
			if(exists($$iso{$fields[0]})) {
			    print "YES\n";
			} else {
			    print "NO\n";
			}
		    }
		}
	    }
	}
    }
    
    # If appropriate, print query results
    unless($$mature_prefix eq "NULL") {
	print "\nQuery $$name verdict: $query_verdict\n";
	print "Query $$name score: $query_score\n";
    }
    
    # Report Locus-wide results
    print "\nLocus verdict: $locus_verdict\n";
    print "Locus score: $locus_score\n";
    
    # Add locus-wide results to ps_info
    $$ps_info .= "\n$locus_verdict";
    $$ps_info .= "\n$locus_score";
    
}


sub print_read_cloud {
    my($read_hash,$seq,$mature_prefix,$name) = @_; ## passed by reference .. hash and scalar, scalar, scalar
    my $i = 0;
    # properly sort the reads
    my %pos_hash = ();
    while ((my $rhk) = each %$read_hash) {
	my @rhkf = split ("_", $rhk);
	$pos_hash{$rhk} = $rhkf[0];
    }
    my @sorted = sort {$pos_hash{$a} <=> $pos_hash{$b}} (keys %pos_hash);
    my %alt_hash = ();
    my $j;
    my @key_fields = ();
    my $subseq;
    my $n;
    my $prefix;
    my $user_query_sequenced;
    foreach my $key (@sorted) {
	++$i;
	$n = $$read_hash{$key};
	$alt_hash{$key} = $i;

	# test
	#print "key: $used_key value $i\n";
	
	
	@key_fields = split ("_", $key);
	for($j = 1; $j < $key_fields[0]; ++$j) {
	    print ".";
	}
	$subseq = substr($$seq,($key_fields[0] - 1),$key_fields[1]);
	print "$subseq";
	for($j = ($key_fields[1] + $key_fields[0]); $j <= (length $$seq); ++$j) {
	    print ".";
	}
	print " seq$i";
	print " l=$key_fields[1]";
	print " a=$n";
	
	$prefix = "$key_fields[0]" . "_" . "$key_fields[1]";
	if($prefix eq $$mature_prefix) {
	    print " <<< $$name\n";
	    $user_query_sequenced = 1;
	} else {
	    print "\n";
	}

    }
    
    unless($$mature_prefix eq "NULL") {
	unless($user_query_sequenced) {
	    print "\n\*\*\* NOTE: No reads matching user query $$name were aligned to this locus\! \*\*\*\n";
	}
    }
    
    return %alt_hash;
}


sub final_scoring {
    my($pro,$fail,$e6) = @_; ## by reference .. hash, hash, scalar
    # pro: at input: offset_length_freq of mirs, values: tab-delimited score string, with first entry offset_length_freq of the star
    # fail: at input: offset_length_freq of mirs, values: tab-delimited score string, with first entry offset_length_freq of the star
    
    my $key;
    my $value;
    my @fields = ();
    my $pf_string;
    while(($key,$value) = each %$pro) {
	@fields = split ("\t", $value);
	## [0] is the star information
	## [1]-[5] : e1 through e5
	## [6]-[10] : s1 through s5
	## [11] : arm information for mir
	## [12] : PASS/FAIL string
	
	# first, modify the PASS/FAIL string if $$e6 is 0
	$pf_string = $fields[12];
	if($$e6 == 0) {
	    if($pf_string eq "PASS") {
		$pf_string = "FAIL:DIFFUSE_PROCESSING";
	    } else {
		$pf_string .= ",DIFFUSE_PROCESSING";
	    }
	}
	
	# Calculate the expression score
	my $score = ((($fields[1] + $fields[2] + $fields[3] + $fields[4] + $fields[5] + $$e6) / 6) +
		     (($fields[6] + $fields[7] + $fields[8] + $fields[9] + $fields[10]) / 5)) / 2;
	
	# round the score
	my $score_r = sprintf("%.3f",$score);
	
	# modify the entry
	my $entry = "$fields[0]\t$score_r\t$pf_string";
	$$pro{$key} = $entry;
	
	# test
	#print "K:$key E:$entry\n";
    }
    
    # repeat for the fail hash
    while(($key,$value) = each %$fail) {
	@fields = split ("\t", $value);
	## [0] is the star information
	## [1]-[5] : e1 through e5
	## [6]-[10] : s1 through s5
	## [11] : arm information for mir
	## [12] : PASS/FAIL string
	
	# first, modify the PASS/FAIL string if $$e6 is 0
	$pf_string = $fields[12];
	if($$e6 == 0) {
	    if($pf_string eq "PASS") {
		$pf_string = "FAIL:DIFFUSE_PROCESSING";
	    } else {
		$pf_string .= ",DIFFUSE_PROCESSING";
	    }
	}
	
	# Calculate the expression score
	my $score = ((($fields[1] + $fields[2] + $fields[3] + $fields[4] + $fields[5] + $$e6) / 6) +
		     (($fields[6] + $fields[7] + $fields[8] + $fields[9] + $fields[10]) / 5)) / 2;
	
	my $score_r = sprintf("%.3f",$score);
	
	# modify the entry
	my $entry = "$fields[0]\t$score_r\t$pf_string";
	$$fail{$key} = $entry;
	# test
	#print "K:$key E:$entry\n";

    }
}

sub get_diversity {
    my($hash) = @_; ## by reference, hash
    my $distinct = scalar (keys %$hash);
    my $count = 0;
    while((my $key, my $value) = each %$hash) {
	$count += $value;
    }
    my $diversity = sprintf("%.3f",($distinct / $count));
    return $diversity;
}

sub get_isomirs {
    my($ok,$notok) = @_;  ## passed by reference, both are hashes
    my %isomirs = ();
    my %fives = ();  ## locations of start positions for ok entries
    my %threes = (); ## locations of stop positions for ok entries
    my $mir;
    my $star;
    while (($mir,$star) = each %$ok) {
	$star =~ s/\t.*$//g;
	# test
	#print "\tworking on mir $mir star $star from hash ok\n";
	my @mfields = split ("_", $mir);
	$fives{$mfields[0]} = 1;
	my $m3 = $mfields[0] + $mfields[1] - 1;
	$threes{$m3} = 1;
	
	unless($star eq "NULL") {
	    my @sfields = split ("_", $star);
	    $fives{$sfields[0]} = 1;
	    my $s3 = $sfields[0] + $sfields[1] - 1;
	    $threes{$s3} = 1;
	}
    }

    while (($mir,$star) = each %$notok) {
	$star =~ s/\t.*$//g;
	# test
	#print "\tworking on mir $mir star $star from hash notok\n";
	my @mfields = split ("_", $mir);
	my $m3 = $mfields[0] + $mfields[1] - 1;
	if(exists($fives{$mfields[0]})) {
	    $isomirs{$mir} = 1;
	}
	if(exists($threes{$m3})) {
	    $isomirs{$mir} = 1;
	}
	
	unless($star =~ /NULL/) {
	    my @sfields = split ("_", $star);
	    my $s3 = $sfields[0] + $sfields[1] - 1;
	    if(exists($fives{$sfields[0]})) {
		$isomirs{$star} = 1;
	    }
	    if(exists($threes{$s3})) {
		$isomirs{$star} = 1;
	    }
	}
    }
    # test
    #print "\nIsomir hash:\n";
    #while((my $xxx, my $yyy) = each %isomirs) {
#	print "KEY:$xxx\tVALUE:$yyy\n";
    #}
    #exit;
    
    return %isomirs;
}
    


sub score_duplex {
    my($mir,$star,$struc_results,$miRType) = @_;
    
    my $verdict;

    # test
    #print "score_duplex: mir $mir star\n";
    
    # Expression-based scores

    # e3: reads of miRNA .. 0-4 is 0, 5-9 is 0.25, 10-49 is 0.5, 50-99 is 0.75, >= 100 is 1 .. 0 is fatal
    my $e3;
    my $mir_freq = $mir;
    $mir_freq =~ s/^.*_//g;
    if($mir_freq <= 4) {
	$e3 = 0;
	## FATAL 
	if($verdict) {
	    $verdict .= ",LOW_MATURE_EXPRESSION";
	} else {
	    $verdict = "FAIL:LOW_MATURE_EXPRESSION";
	}
    } elsif (($mir_freq > 4) and ($mir_freq <= 9)) {
	$e3 = 0.25;
    } elsif (($mir_freq > 9) and ($mir_freq <= 49)) {
	$e3 = 0.5;
    } elsif (($mir_freq > 49) and ($mir_freq <= 99)) {
	$e3 = 0.75;
    } else {
	$e3 = 1;
    }
    # test
    #print "\tmir_freq: $mir_freq\n";
    #print "\te3 reads of miRNA $e3\n";
    
    
    # e4: reads of star .. 0 is 0, 1-5 is 0.5, 6 or more is 1. 0 is FATAL
    my $e4;
    my $star_freq;
    if($star eq "NULL") {
	$star_freq = 0;
    } else {
	$star_freq = $star;
	$star_freq =~ s/^.*_//g;
    }
    if($star_freq == 0) {
	$e4 = 0;
	# FATAL
	if($verdict) {
	    $verdict .= ",NO_STAR_EXPRESSED";
	} else {
	    $verdict = "FAIL:NO_STAR_EXPRESSED";
	}
    } elsif (($star_freq > 0) and ($star_freq <= 5)) {
	$e4 = 0.5;
    } elsif ($star_freq > 5) {
	$e4 = 1;
    }
    # test
    #print "\tstar_freq $star_freq\n";
    #print "\te4 reads of star $e4\n";

    # e5 : length of miRNA. score 0 if <20 or >24 (FATAL), 1 if 20, 21, or 22, 0.5 if 23, and 0.25 if 24
    my $e5;
    my $mir_length;
    if($mir =~ /^\d+_(\d+)_/) {
	$mir_length = $1;
    } else {
	$mir_length = 0;
    }
    if(($mir_length < 20) or ($mir_length > 24)) {
	$e5 = 0;
	# FATAL
	if($verdict) {
	    $verdict .= ",BAD_MIR_LENGTH";
	} else {
	    $verdict = "FAIL:BAD_MIR_LENGTH";
	}
    } elsif (($mir_length ==20) or ($mir_length ==21) or ($mir_length ==22)) {
	$e5 = 1;
    } elsif ($mir_length == 23) {
	$e5 = 0.5;
    } elsif ($mir_length == 24) {
	$e5 = 0.25;
    }

    
    ## structure-based scoring
    # s1: self-pairing of mature miRNA
    my $mir_lookup = $mir;
    $mir_lookup =~ s/_(\d+)$//g;
    my $mir_brac = get_brax_subset($mir_lookup,$struc_results);
    my $arm = score_brac_pairing($mir_brac);
    my $s1;
    if($arm >= 1) {
	$s1 = 1;
    } else {
	$s1 = 0;
    }
    if($s1 == 0) {
	## FATAL
	if($verdict) {
	    $verdict .= ",MIR_NOT_ON_STEM";
	} else {
	    $verdict = "FAIL:MIR_NOT_ON_STEM";
	}
    }
    # test
    #print "\t mir_lookup: $mir_lookup mir_brac: $mir_brac arm: $arm\n";
    #print "\t s1 self-pairing of mature miRNA: $s1\n";

    # s2: miR unpaired nts .. 1 for 0-3, 0.5 for 4, 0.25 for 5, 0 for 6 or more. 
    my $s2;
    my $mir_up = count_duplex_unpairs($mir_brac);
    if($mir_up <= 3) {
	$s2 = 1;
    } elsif ($mir_up == 4) {
	$s2 = 0.5;
    } elsif ($mir_up == 5) {
	$s2 = 0.25;
    } else {
	$s2 = 0;
	# FATAL
	if($verdict) {
	    $verdict .= ",GT6_UP_MIR";
	} else {
	    $verdict = "FAIL:GT6_UP_MIR";
	}
    }
    # test
    #print "\tmir_up: $mir_up\n";
    #print "\ts2 .. miR unpaired nts $s2\n";
    
    # s3: simply whether or not the star was computable .. if its not, FATAL!
    my $s3;
    if($star =~ /^NULL/) {
	$s3 = 0;
	# FATAL
	if($verdict) {
	    $verdict .= ",STAR_NOT_COMPUTABLE";
	} else {
	    $verdict = "FAIL:STAR_NOT_COMPUTABLE";
	}
    } else {
	$s3 = 1;
    }
    # test
    #print "\ts3 .. star computable $s3\n";
    
    # s4 and s5 are dependent upon star being computable ...
    #  if s3 is 0, we know verdict is fail. No need to add the s4 and s5 error messages, they won't make sense if no star is computable anyway
    my $s4;
    my $s5;
    if($s3) {
	# s4: total assymetric nts. in miR/miR* duplex. 0-1 is 1, 2 is 0.5, 3 is 0.25, >= 4 OR non-computed star is 0. 0 is fatal
	my $assym;
	my $star_lookup = $star;
	$star_lookup =~ s/_(\d+)$//g;
	$assym = check_duplex_struc($mir_lookup,$star_lookup,$struc_results,$arm);
	if($assym >=4) {
	    $s4 = 0;
	    # FATAL
	    if($verdict) {
		$verdict .= ",TOO_MANY_BULGES";
	    } else {
		$verdict = "FAIL:TOO_MANY_BULGES";
	    }
	} elsif ($assym == 3) {
	    $s4 = 0.25;
	} elsif ($assym == 2) {
	    $s4 = 0.5;
	} else {
	    $s4 = 1;
	}
	# test
	#print "\tassym: $assym\n";
	#print "\ts4 total assymetric nts $s4\n";
	
	# s5 .. buffer size for plants .. 1 if 15 or more, 0.5 if 13 or 14, 0.25 if 12 or 11, 0.1 if 10, 0 if less than ten OR if no STAR computed. 0 is FATAL

	my $stem_pos = get_stem_pos($mir_lookup,$star_lookup,$struc_results,$arm);
	my $max_buffer = get_max_buffer($mir_lookup,$star_lookup,$stem_pos,$arm);
	if($miRType eq "plant") {
	    if($max_buffer < 10) {
		$s5 = 0;
		# FATAL
		if($verdict) {
		    $verdict .= ",INSUFFICIENT_BUFFER";
		} else {
		    $verdict = "FAIL:INSUFFICIENT_BUFFER";
		}
	    } elsif ($max_buffer == 10) {
		$s5 = 0.1;
	    } elsif (($max_buffer == 11) or ($max_buffer == 12)) {
		$s5 = 0.25;
	    } elsif (($max_buffer == 13) or ($max_buffer == 14)) {
		$s5 = 0.5;
	    } else {
		$s5 = 1;
	    }
	} elsif ($miRType eq "animal") {
	    if($max_buffer < 6) {
		$s5 = 0;
		# FATAL
		if($verdict) {
		    $verdict .= ",INSUFFICIENT_BUFFER";
		} else {
		    $verdict = "FAIL:INSUFFICIENT_BUFFER";
		}
	    } elsif ($max_buffer == 7) {
		$s5 = 0.1;
	    } elsif ($max_buffer == 8) {
		$s5 = 0.25;
	    } elsif (($max_buffer == 9) or ($max_buffer == 10)) {
		$s5 = 0.5;
	    } else {
		$s5 = 1;
	    }
	}
	    
	# test
	#print "\tstem_pos: $stem_pos max_buffer: $max_buffer\n";
	#print "\ts5 buffer size $s5\n";
	
    } else {
	$s4 = 0;
	$s5 = 0;
	# test
	#print "\ts4 and s5 set to 0\n";
    }
    
    # if nothing has been entered to the verdict, the duplex passed.
    unless($verdict) {
	$verdict = "PASS";
    }
    
    # gather the information
    my $out = "$e3\t$e4\t$e5\t$s1\t$s2\t$s3\t$s4\t$s5\t$arm\t$verdict";
    # test
    #print "\t$out\n";
    return $out;
}    
    

sub get_seq {
    my($query,$struc_results) = @_; 
    if($query eq "NULL") {
	return "\*null\*";
    } else {
	my @sr = split ("\t", $struc_results);  # [0]: brax, [1]: seq, [2]: local start 
	my @q = split ("_", $query); # [0]: start (one-based), [1]: length, [2]: frequency
	my $out = substr($sr[1], ($q[0] - 1), $q[1]);
	return $out;
    }
}
	

sub get_duplex_hash {
    my($read_hash,$struc_results) = @_; ## by reference .. hash and string
    my %out = ();
    my %partnered = ();
    my $key;
    my $freq;
    my $long_key;
    my $long_freq;

    my %read_hash_short = ();
    while(($long_key, $long_freq) = each %$read_hash) {
	my @lkf = split ("_", $long_key);
	my $short_key = "$lkf[0]" . "_" . "$lkf[1]";
	$read_hash_short{$short_key} = $long_key;
    }
    
    # find the partners
    while (($key,$freq) = each %$read_hash) {
	# test
	#print "key: $key freq: $freq\n";
	if(exists($partnered{$key})) {
	    # test
	    #print "\tkey existed in partnered hash\n";
	    next;
	}
	my $brac1 = get_brax_subset($key,$$struc_results);
	# test
	#print "\tbrac1: $brac1\n";
	my $brac1_pairing = score_brac_pairing($brac1);
	# test
	#print "\tbrac1_pairing: $brac1_pairing\n";
	my $brac1_d_up = count_duplex_unpairs($brac1);
	# test
	#print "\tbrac1_d_up: $brac1_d_up\n";
	my $other = '';
	if(($brac1_pairing) and ($brac1_d_up <= 6)) {
	    $other = get_star($key,$$struc_results,$brac1_pairing);
	    # test
	    #print "\tother: $other\n";
	}
	# build new name
	my $one_name = "$key" . "_$freq";
	# test
	#print "\tone_name: $one_name\n";
	
	my $two_name;
	if($other) {
	    # Get frequency of the other
	    my $other_freq = 0;
	    if(exists($read_hash_short{$other})) {
		$long_key = $read_hash_short{$other};
		$other_freq = $$read_hash{$long_key};
		$two_name = "$long_key" . "_$other_freq";
	    } else {
		$two_name = "$other" . "_NULL_NULL_NULL_0"; ## fields for the XX, XY, XZ, and frequency filled in here
		$long_key = "$other" . "_NULL_NULL_NULL";
	    }
	    # test
	    #print "\ttwo_name: $two_name\n";
	    if($other_freq > $freq) {
		$out{$two_name} = $one_name;
		# test
		#print "\tout: $two_name keyed to $one_name\n";
	    } else {
		$out{$one_name} = $two_name;
		# test
		#print "\tout: $one_name keyed to $two_name\n";
	    }
	    $partnered{$long_key} = 1;
	    # test
	    #print "\tadded $long_key to partnered hash\n";
	} else {
	    $out{$one_name} = "NULL_NULL_NULL_NULL_NULL_0";
	    # test
	    #print "\tout: $one_name keyed to $out{$one_name}";
	}
	# test
	#print "\tadded $key to partnered hash\n";
	$partnered{$key} = 1;
    }
    # test
    #exit;
    return %out;
}



    
    
    

sub get_sorted_rh_keys {
    my($hash) = @_; ## passed by ref
    my %new = ();
    my $key;
    my @fields = ();
    while(($key) = each %$hash) {
	@fields = split ("_", $key);
	$new{$key} = $fields[0];
    }
    my @sorted = sort { $new{$a} <=> $new{$b} } keys %new;
    return @sorted;
}


sub print_align_summary {
    my($read_hash) = @_;  ## passed by reference
    my %freq = ();
    my $key;
    my $freq;
    my $count;
    my @fields = ();
    while(($key,$count) = each %$read_hash) {
	@fields = split ("_", $key);
	if($fields[1] < 20) {
	    $freq{'small'} += $count;
	} elsif ($fields[1] > 24) {
	    $freq{'large'} += $count;
	} else {
	    $freq{$fields[1]} += $count;
	}
    }
    print "RNA_SIZE\tALIGNMENTS\n"; 
    if(exists($freq{'small'})) {
	print "<20\t$freq{'small'}\n";
    } else {
	print "<20\t0\n";
    }
    for (my $i = 20; $i <= 24; ++$i) {
	if(exists($freq{$i})) {
	    print "$i\t$freq{$i}\n";
	} else {
	    print "$i\t0\n";
	}
    }
    if(exists($freq{'large'})) {
	print ">24\t$freq{'large'}\n";
    } else {
	print ">24\t0\n\n";
    }
}
	
sub score_it {
    my(@in) = @_;
    my @fails = ();
    my $overall_score = 0;
    my $exp_weight = sprintf("%.4f",(0.5 / 6));
    my $str_weight = sprintf("%.4f",(0.5 / 5));
    my $this_score;
    
    print "\*\*\* EXPRESSION-BASED EVALUATION WEIGHTED AT $exp_weight each\n";
    print "\tSCORE\tITEM:VALUE\n";
    
    # [2] : m-map corrected reads .. 0-4 is 0, 5-9 is 0.25, 10-49 is 0.5, 50-99 is 0.75, >= 100 is 1
    if($in[2] < 5) {
	$this_score = 0;
    } elsif ($in[2] < 10) {
	$this_score = 0.25;
    } elsif ($in[2] < 50) {
	$this_score = 0.5;
    } elsif ($in[2] < 100) {
	$this_score = 0.75;
    } else {
	$this_score = 1;
    }
    print "\t$this_score\tMULTI-MAPPED_CORRECTED_READ_TOTAL:$in[2]\n";
    $overall_score += ($exp_weight * $this_score);


    # [3] : uniquely mapped reads .. 0 for 0, 1 for 1 or more.
    if($in[3] > 0) {
	$this_score = 1;
    } else {
	$this_score = 0;
    }
    print "\t$this_score\tUNIQUELY_MAPPED_READS:$in[3]\n";
    $overall_score += ($exp_weight * $this_score);
    
    # [10] : reads of star .. 0 is 0, 1-5 is 0.5, 6 or more is 1.
    if($in[10] >= 6) {
	$this_score = 1;
    } elsif (($in[10] >= 1) and ($in[10] <= 5)) {
	$this_score = 0.5;
    } else {
	$this_score = 0;
	push(@fails,"NO_STAR_EXPRESSED");
    }
    print "\t$this_score\tSTAR_READS:$in[10]\n";
    $overall_score += ($exp_weight * $this_score);
    
    # [11] : reads of mature miR .. 0-4 is 0, 5-9 is 0.25, 10-49 is 0.5, 50-99 is 0.75, >= 100 is 1 .. 0 is fatal
    if(($in[11] >= 5) and ($in[11] <= 9)) {
	$this_score = 0.25;
    } elsif (($in[11] >= 10) and ($in[11] <= 49)) {
	$this_score = 0.5;
    } elsif (($in[11] >= 50) and ($in[11] <= 99)) {
	$this_score = 0.75;
    } elsif ($in[11] >= 100) {
	$this_score = 1;
    } else {
	$this_score = 0;
	push(@fails,"LOW_MATURE_EXPRESSION");
    }
    print "\t$this_score\tmiRNA_READS:$in[11]\n";
    $overall_score += ($exp_weight * $this_score);
    
    # [13] : precision ... as is.
    print "\t$in[13]\tPRECISION:$in[13]\n";
    $overall_score += ($exp_weight * $in[13]);
    if($in[13] < 0.25) {
	push(@fails,"IMPRECISE");
    }
    
    # [15] : if miR abun >= star_abun . as is (1 or 0)
    print "\t$in[15]\tMIR_GTEQ_STAR:$in[15]\n";
    $overall_score += ($exp_weight * $in[15]);
    unless($in[15]) {
	push(@fails,"STAR_GT_MIR");
    }

    print "\*\*\* STRUCTURE-BASED EVALUATION WEIGHTED AT $str_weight each\n";
    print "\tSCORE\tITEM:VALUE\n";

    # [5] : self-pairing of miRNA .. 0 for 0, 1 for anything else (1 or 2)
    my $arm;
    if($in[5] == 0) {
	$this_score = 0;
	push(@fails,"MIR_NOT_ON_STEM");
	$arm = "NA";
    } elsif ($in[5] == 1) {
	$this_score = 1;
	$arm = "5p";
    } elsif ($in[5] == 2) {
	$this_score = 1;
	$arm = "3p";
    }
    print "\t$this_score\tMIR_ARM:$arm\n";
    $overall_score += ($str_weight * $this_score);
    
    # [6] : miR unpaired nts .. 1 for 0-3, 0.5 for 4, 0.25 for 5, 0 for 6 or more.
    if($in[6] <= 3) {
	$this_score = 1;
    } elsif ($in[6] == 4) {
	$this_score = 0.5;
    } elsif ($in[6] == 5) {
	$this_score = 0.25;
    } else {
	$this_score = 0.25;
	push(@fails,"GT6_UP_MIR");
    }
    print "\t$this_score\tMIR_UNPAIRED:$in[6]\n";
    $overall_score += ($str_weight * $this_score);

    # [7] : miR* able to be deduced. as is .. either 1 or 0.
    print "\t$in[7]\tSTAR_COMPUTABLE:$in[7]\n";
    $overall_score += ($str_weight * $in[7]);
    unless($in[7]) {
	push(@fails,"STAR_NOT_COMPUTABLE");
    }
    
    # [8] : total assymetric nts. in miR/miR* duplex. 0-1 is 1, 2 is 0.5, 3 is 0.25, >= 4 is 0. 0 is fatal.
    if(($in[8] == 0) or ($in[8] == 1)) {
	$this_score = 1;
    } elsif ($in[8] == 2) {
	$this_score = 0.5;
    } elsif ($in[8] == 3) {
	$this_score = 0.25;
    } elsif ($in[8] > 3) {
	$this_score = 0;
	push(@fails,"TOO_MANY_BULGES");
    } elsif ($in[8] == -1) {
	$this_score = 0;
    }
    print "\t$this_score\tN_BULGES_DUPLEX:$in[8]\n";
    $overall_score += ($str_weight * $this_score);
    
    # [9] : buffer size .. 1 if 15 or more, 0.25 if 13 or 14, 0 if less than 13.
    if($in[9] >= 15) {
	$this_score = 1;
    } elsif (($in[9] == 13) or ($in[9] == 14)) {
	$this_score = 0.25;
    } else {
	$this_score = 0;
#	push(@fails,"INSUFFICIENT_BUFFER");  ## Decided against failing loci for insufficient buffer. Not in the Meyers et al. criteria.
    }
    print "\t$this_score\tMAX_STEM_BUFFER:$in[9]\n";
    $overall_score += ($str_weight * $this_score);
    
    my $overall_rounded_score = sprintf("%.3f",$overall_score);
    
    print "\*\*\* SUMMARY\n";
    print "\tOVERALL_SCORE:$overall_rounded_score\n";
    print "\tOVERALL_VERDICT:";
    if($fails[0]) {
	print "FAIL:@fails\n";
    } else {
	print "PASS\n";
    }
}

sub check_counts {
    my(@sam) = @_;
    my $all = 0;
    my $uniques = 0;
    foreach my $samline (@sam) {
	++$all;
	if($samline =~ /\tXY:Z:U/) {
	    ++$uniques;
	}
    }
    return($all,$uniques);
}
	

sub select_user_mir {
    my($mature_match,$read_hash) = @_; ## passed by reference,, array and hash
    my $max;
    my $max_mat;
    foreach my $mat (@$mature_match) {
	if($max_mat) {
	    if(exists($$read_hash{$mat})) {
		if($$read_hash{$mat} > $max) {
		    $max = $$read_hash{$mat};
		    $max_mat = $mat;
		}
	    }
	} else {
	    ## First time enter no matter what
	    if(exists($$read_hash{$mat})) {
		$max = $$read_hash{$mat};
		$max_mat = $mat;
	    } else {
		$max = 0;
		$max_mat = $mat;
	    }
	}
    }
    return $max_mat;
}
    

sub get_max_buffer {
    my($mir,$star,$stem_pos,$strand) = @_;
    # TEST
    #print STDERR "\tInput to get_max_buffer is mir $mir star $star stem_pos $stem_pos strand $strand\n";
    my @m = split ("_", $mir);
    my @s = split ("_", $star);
    my $mir_end = $m[0] + $m[1] - 1;
    my $star_end = $s[0] + $s[1] - 1;
    #TEST
    #print STDERR "\tmir_end $mir_end star_end $star_end\n";
    my $base_5;
    my $loop_5;
    my $loop_3;
    my $base_3;
    if($stem_pos =~ /^(\d+)-(\d+)\,(\d+)-(\d+)$/) {
	$base_5 = $1;
	$loop_5 = $2;
	$loop_3 = $3;
	$base_3 = $4;
    } else {
	return 0;
    }
    # TEST
    #print STDERR "\tbase_5 $base_5 loop_5 $loop_5 loop_3 $loop_3 base_3 $base_3\n";
    my $low;
    my $high;
    if($strand == 1) {
	# miR is on the 5p arm
	# TEST
	#print STDERR "\t5p arm detected\n";
	$low = 0.5 * (($m[0] - $base_5) + ($base_3 - $star_end));
	$high = 0.5 * (($loop_5 - $mir_end) + ($s[0] - $loop_3));
	# TEST
	#print STDERR "\tlow $low high $high\n";
    } elsif ($strand == 2) {
	# miR is on the 3p arm
	# TEST
	#print STDERR "\t3p arm detected\n";
	$low = 0.5 * (($s[0] - $base_5) + ($base_3 - $mir_end));
	$high = 0.5 * (($loop_5 - $star_end) + ($m[0] - $loop_3));
	# TEST
	#print STDERR "\tlow $low high $high\n";
    } else {
	return 0;
    }
    if($low >= $high) {
	# TEST
	#print STDERR "\treturned low of $low\n";
	return $low;
    } else {
	# TEST
	#print STDERR "\treturned high of $high\n";
	return $high;
    }
}
    

sub get_stem_pos {
    my($mir,$star,$struc_results,$strand) = @_;
    my @m = split ("_", $mir);
    my @s = split ("_", $star);
    my @st = split ("\t",$struc_results);
    my $mir_end = $m[0] + $m[1] - 1;
    my $star_end = $s[0] + $s[1] - 1;
    my $five_base;
    my $five_loop;
    my $three_base;
    my $three_loop;
    if($strand == 1) {
	$five_base = $m[0];
	$five_loop = $mir_end;
	$three_loop = $s[0];
	$three_base = $star_end;
    } elsif ($strand == 2) {
	$five_base = $s[0];
	$five_loop = $star_end;
	$three_loop = $m[0];
	$three_base = $mir_end;
    } else {
	return 0;
    }
    my %lr = get_lr($st[0]);
    my %rl = get_rl($st[0]);


    my $i;
    
    # Find the ends ..
    # first, 5p_start
    my $last_ok = $five_base; ## not necessarily paired
    for($i = $five_base; $i > 0; --$i) {
	if(exists($rl{$i})) {
	    last;
	} elsif (exists($lr{$i})) {
	    $last_ok = $i;
	}
    }
    my $five_base_min = $last_ok;
    
    # now, 5p_loop_max
    $last_ok = $five_loop;
    for($i = $five_loop; $i < $three_loop; ++$i) {
	if(exists($rl{$i})) {
	    last;
	} elsif (exists($lr{$i})) {
	    $last_ok = $i;
	}
    }
    my $five_loop_max = $last_ok;
    
    # 3p_loop_min
    $last_ok = $three_loop;
    for($i = $three_loop; $i > $five_loop; --$i) {
	if(exists($lr{$i})) {
	    last;
	} elsif (exists($rl{$i})) {
	    $last_ok = $i;
	}
    }
    my $three_loop_min = $last_ok;
    
    # 3p_base_max
    $last_ok = $three_base;
    for($i = $three_base; $i < (length $st[0]); ++$i) {
	if(exists($lr{$i})) {
	    last;
	} elsif (exists($rl{$i})) {
	    $last_ok = $i;
	}
    }
    my $three_base_max = $last_ok;
    
    # Consensus
    my $start_5;
    my $stop_5;
    my $start_3;
    my $stop_3;
    
    # Safeguard against really aberrant structures
    
    if (($lr{$five_base_min}) and ($three_base_max) and ($lr{$five_base_min} <= $three_base_max)) {
	$start_5 = $five_base_min;
	$stop_3 = $lr{$five_base_min};
    } elsif (($rl{$three_base_max}) and ($three_base_max)) {
	$start_5 = $rl{$three_base_max};
	$stop_3 = $three_base_max;
    } else {
	return 0;
    }
    
    if(($lr{$five_loop_max}) and ($three_loop_min) and ($lr{$five_loop_max} <= $three_loop_min)) {
	$stop_5 = $rl{$three_loop_min};
	$start_3 = $three_loop_min;
    } elsif (($five_loop_max) and ($lr{$five_loop_max})) {
	$stop_5 = $five_loop_max;
	$start_3 = $lr{$five_loop_max};
    } else {
	return 0;
    }
    
    # final failsafe .. all have to be defined 
    unless(($start_5) and ($stop_5) and ($start_3) and ($stop_3)) {
	return 0;
    }
    
    my $out = "$start_5" . "-" . "$stop_5" . "," . "$start_3" . "-" . "$stop_3";  
    return $out;
}
	
    
sub check_duplex_struc {
    my($mir,$star,$struc_result,$arm) = @_;
    
    # Parse mir and star
    my @ma = split ("_",$mir);  ## [0] is left-most, [1] is length
    my $mir_end = $ma[0] + $ma[1] - 1;
    my @sa = split ("_",$star); 
    my $star_end = $sa[0] + $sa[1] - 1;
    
    # Parse $struc_results
    my @st = split ("\t", $struc_result);  ## [0] is brax
    
    # Initialize counters
    my $bul_n = 0;
    my $bul_nts = 0;
    my $ail_n = 0;
    my $ail_nts = 0;
    
    # Get left-right hash
    my %lr = get_lr($st[0]);
    
    my $i;
    my $last_left;
    my $last_right;
    my $ldiff;
    my $rdiff;
    my $start;
    my $stop;
    if($arm == 1) {
	$start = $ma[0];
	$stop = $mir_end - 2;
    } elsif ($arm == 2) {
	$start = $sa[0];
	$stop = $star_end - 2;
    }
    # failsafe for rare error
    unless(($start) and ($stop)) {
	return 100;
    }
    for ($i = $start; $i <= $stop; ++$i) {
	if(exists($lr{$i})) {
	    if($last_left) {
		$ldiff = $i - $last_left;
		$rdiff = $last_right - $lr{$i};
		if (($ldiff == 1) and ($rdiff > 1)) {
		    # bulge
		    ++$bul_n;
		    $bul_nts += $rdiff - 1;
		} elsif (($ldiff > 1) and ($rdiff == 1)) {
		    # the other bulge
		    ++$bul_n;
		    $bul_nts += $ldiff - 1;
		} elsif (($ldiff > $rdiff) or ($ldiff < $rdiff)) {
		    # ail
		    ++$ail_n;
		    $ail_nts += abs ($ldiff - $rdiff);
		}
	    }
	    $last_left = $i;
	    $last_right = $lr{$i};
	}
    }
    # simplification .. report the number of assym nts
    my $out = $bul_nts + $ail_nts;
    return $out;
}
		
		
    

sub get_star {
    my($mir,$struc_results,$arm) = @_;
    # Parse mir
    my @ma = split ("_",$mir);  ## [0] is left-most, [1] is length
    # Parse $struc_results
    my @st = split ("\t", $struc_results);  ## [0] is brax
    my $star_5p;
    my $star_3p;
    # Different methods depending upon the arm of the mir
    if($arm == 1) {
	# mir is 5p arm, miR* is on 3p arm
	# get left-right lookup hash
	my %left_right = get_lr($st[0]);
	$star_5p = get_star_5p_1(\%left_right,\$mir);
	$star_3p = get_star_3p_1(\%left_right,\$mir);
    } elsif($arm == 2) {
	## mir is 3p arm, miR* is on 5p arm
	my %right_left = get_rl($st[0]);
	$star_5p = get_star_5p_2(\%right_left,\$mir);
	$star_3p = get_star_3p_2(\%right_left,\$mir);
    } else {
	return 0;
    }
    if(($star_5p) and ($star_3p)) {
	my $len = $star_3p - $star_5p + 1;
	my $out = "$star_5p" . "_" . "$len";
	return $out;
    } else {
	return 0;
    }
}

sub get_star_3p_2 {
    my($rl_hash,$mir) = @_; ## passed by reference. hash and scalar
    # parse mir
    my @mf = split ("_", $$mir);
    my $mir_end = $mf[0] + $mf[1] - 1;
    # Find the 3p end of the miR* for a miR on the 3p arm. This is across from the 5p end of the mir and then add 2
    my $i = $mf[0];
    until(exists($$rl_hash{$i})) {
	++$i;
	# sanity check / prevent infinite loop
	if($i >= $mir_end) {
	    return 0;
	}
    }
    my $j = $$rl_hash{$i};
    my $diff = $i - $mf[0] + 2; ## Add two for the 3' overhang
    my $star_3 = $j + $diff;
    return $star_3;
}
    
sub get_star_5p_2 {
    my($rl_hash,$mir) = @_; ## passed by reference. hash and scalar
    # parse mir
    my @mf = split ("_", $$mir);
    my $mir_end = $mf[0] + $mf[1] - 1;
    # Find the 5p end of the miR* for a miR on the 3p arm. This is across the 3p end of the miR - 2
    my $mir_end_less2 = $mir_end - 2;
    my $i = $mir_end_less2;
    until(exists($$rl_hash{$i})) {
	--$i;
	# sanity check / prevent infinite loop
	if($i <= $mf[0]) {
	    return 0;
	}
    }
    my $j = $$rl_hash{$i};
    my $diff = $mir_end_less2 - $i;
    my $star_5 = $j - $diff;
    return $star_5;
}
    
sub get_rl {
    my($brax) = @_;
    my %lr = get_lr($brax);
    my %rl = ();
    my $left;
    my $right;
    while(($left,$right) = each %lr) {
	$rl{$right} = $left;
    }
    return %rl;
}

sub get_star_3p_1 {
    my($lr_hash,$mir) = @_;  ## passed by reference. hash and scalar
    # Parse mir
    my @mf = split ("_", $$mir);
    my $mir_end = $mf[0] + $mf[1] - 1;
    # find the 3p of the miR* for a miR on the 5p arm.  This is across of the 5p of mir and then add 2
    my $i = $mf[0];
    until (exists($$lr_hash{$i})) {
	++$i;
	# sanity check / prevent infinite loop
	if($i >= $mir_end) {
	    return 0;
	}
    }
    my $j = $$lr_hash{$i};
    my $diff = $i - $mf[0] + 2; ## add two to account for two nt overhang
    my $star_3 = $j + $diff;
    return $star_3;
}

sub get_star_5p_1 {
    my($lr_hash,$mir) = @_;  ## passed by reference. hash and scalar
    # Parse mir
    my @mf = split ("_", $$mir);
    my $mir_end = $mf[0] + $mf[1] - 1;
    # find the 5p of the miR* for a miR on the 5p arm.  This is across of the 3p of mir - 2
    my $mir_end_less2 = $mir_end - 2;
    my $i = $mir_end_less2;
    until (exists($$lr_hash{$i})) {
	--$i;
	# sanity check / prevent infinite loop
	if($i <= $mf[0]) {
	    return 0;
	}
    }
    my $j = $$lr_hash{$i};
    my $diff = $mir_end_less2 - $i;
    my $star_5 = $j - $diff;
    return $star_5;
}

sub get_lr {
    my($brax) = @_;
    my %hash = ();
    my @char = split ('',$brax);
    my @lefts = ();
    my $i = 0;
    my $left;
    foreach my $ch (@char) {
	++$i;
	if($ch eq "\(") {
	    push(@lefts,$i);
	} elsif ($ch eq "\)") {
	    $left = pop @lefts;
	    $hash{$left} = $i;
	}
    }
    return %hash;
}

sub count_duplex_unpairs {
    my($brac) = @_;
    my $chopped = substr($brac,0,((length $brac) - 2));
    my $unp = 0;
    while ($chopped =~ /\./g) {
	++$unp;
    }
    return $unp;
}
    
    
sub score_brac_pairing {
    my($brac) = @_;
    my $score = 0;
    if($brac =~ /^[\.\(]+$/) {
	$score = 1; ## 5p arm .. all pairs are (
    } elsif ($brac =~ /^[\.\)]+$/) {
	$score = 2; ## 3p arm .. all pairs and )
    }
    return $score;
}
    

sub get_brax_subset {
    my($query,$struc_results) = @_;
    # Parse out query and struc_results
    my @qf = split ("_",$query);
    my @sr = split ("\t", $struc_results);
    my $offset = $qf[0] - 1; ## adjust to zero-based
    my $getlen = $qf[1];
    my $brax_subset = substr($sr[0],$offset,$getlen);
    return $brax_subset;
}

sub get_most_abun {
    my(%reads) = @_;
    my $max_freq = 0;
    my $max_entry;
    my $entry;
    my $freq;
    ## Note in case of ties, decision of which one to keep is arbitrary, based on the hash order
    while(($entry,$freq) = each %reads) {
	if($freq > $max_freq) {
	    $max_freq = $freq;
	    $max_entry = $entry;
	}
    }
    return $max_entry;
}

sub check_mature_match {
    my($mature,$sr) = @_;
    my @mature_match;
    my @srt = split ("\t", $sr);
    my $seq = $srt[1];
    my $mat_start;
    my $mat_key;
    my $mat_length = length $mature;
    while($seq =~ /$mature/g) {
	$mat_start = (pos $seq) - (length $mature) + 1;
	$mat_key = "$mat_start" . "_" . "$mat_length";
	push(@mature_match,$mat_key)
    }
    return @mature_match;
}

sub get_read_hash {
    my($sam,$mod_query,$strand) = @_; ## Passed by reference
    # test
    #print STDERR "mod_query is $mod_query\n";
    
    # Parse mod_query coordinates
    my $pos_offset;
    my $neg_offset;
    if($$mod_query =~ /^\S+:(\d+)-(\d+)$/) {
	$pos_offset = $1;
	$neg_offset = $2;
    } else {
	die "Abort. Parse failure of mod_query $$mod_query in sub-routine get_read_hash\n";
    }
    my %hash = ();
    my @fields = ();
    my $read_len;
    my $mod_pos;
    my $key;
    my $read_end;
    
    my %hash_XX = ();
    my %hash_XY = ();
    my %hash_XZ = ();
    foreach my $sam_line (@$sam) {
	chomp $sam_line;
	
	# test
	#print STDERR "$sam_line\n";
	
	@fields = split ("\t", $sam_line);
	$read_len = length $fields[9];
	
	# test
	#print STDERR "read_len: $read_len\n";
	
	if($$strand eq "+") {
	    $mod_pos = $fields[3] - $pos_offset + 1;
	    # test
	    #print STDERR "mod_pos of $mod_pos from fields3 $fields[3] - pos_offset $pos_offset + 1\n";
	} elsif ($$strand eq "-") {
	    $read_end = $fields[3] + $read_len - 1;
	    # test
	    #print STDERR "read_end of $read_end from fields3 $fields[3] + read_len $read_len - 1\n";
	    $mod_pos = $neg_offset - $read_end + 1;
	    # test
	    #print STDERR "mod_pos of $mod_pos from neg_offset of $neg_offset - read_end of $read_end + 1\n";
	} else {
	    die "Abort: Failed to parse \$\$strand in sub-routine get_read_hash\n";
	}
	$key = "$mod_pos" . "_" . "$read_len";
	# test
	#print STDERR "key of $key entered from mod_pos $mod_pos and read_len $read_len\n";
	
	++$hash{$key};
	
	# parse custom tags
	if($sam_line =~ /\tXX:i:(\d+)/) {
	    push(@{$hash_XX{$key}}, $1);
	}
	if($sam_line =~ /\tXY:Z:([NURPM])/) {
	    push(@{$hash_XY{$key}}, $1);
	}
	if($sam_line =~ /\tXZ:f:([^\t\n]+)/) {
	    push(@{$hash_XZ{$key}}, $1);
	}
    }
    # get consensus on custom tags
    my %final_hash = ();
    while(($key) = each %hash) {
	my $xx_median = get_xx_median(\%hash_XX,\$key);
	my $xy_consensus = get_xy_consensus(\%hash_XY,\$key);
	my $xz_median = get_xz_median(\%hash_XZ,\$key);
	my $count = $hash{$key};
	$key .= "_$xx_median" . "_$xy_consensus" . "_$xz_median";
	$final_hash{$key} = $count;
	# test
	#print "Key $key value $count in final_hash\n";
    }
    # test
    #exit;
    
    return %final_hash;
}

sub get_xy_consensus {
    my($hash,$key) = @_; ## by reference .. hash and scalar
    my @values = @{$$hash{$$key}};
    my %counts = ();
    foreach my $val (@values) {
	++$counts{$val};
    }
    my @sorted = sort {$counts{$b} <=> $counts{$a}} keys %counts;
    my $consensus = $sorted[0];
    return $consensus;
}
	
sub get_xx_median {
    my($xx_hash,$key) = @_; ## by reference, a hash, and a scalar
    my @values = sort {$a <=> $b} (@{$$xx_hash{$$key}});
    my $med_idx1;
    my $med_idx2;
    my $median;
    unless($values[0]) {
	return 0;
    }
    if ((scalar @values) % 2) {
	# odd number of entries, so the median is the central value
	$med_idx1 = int((scalar @values) / 2);
	$median = $values[$med_idx1];
	return $median;
    } else {
	# even number of entries, so median is the mean of the two middle-most entries
	$med_idx2 = int((scalar @values) / 2);
	$med_idx1 = $med_idx2 - 1;
	# return only integers for XX:i 
	$median = int(($values[$med_idx1] + $values[$med_idx2]) * 0.5);
	return $median;
    }
}
sub get_xz_median {
    my($xz_hash,$key) = @_; ## by reference, a hash, and a scalar
    my @values = sort {$a <=> $b} (@{$$xz_hash{$$key}});
    my $med_idx1;
    my $med_idx2;
    my $median;
    unless($values[0]) {
	return 0;
    }
    if ((scalar @values) % 2) {
	# odd number of entries, so the median is the central value
	$med_idx1 = int((scalar @values) / 2);
	$median = sprintf("%.3f",$values[$med_idx1]);
	return $median;
    } else {
	# even number of entries, so median is the mean of the two middle-most entries
	$med_idx2 = int((scalar @values) / 2);
	$med_idx1 = $med_idx2 - 1;
	# round the floats to 3 digits
	$median = sprintf("%.3f",(($values[$med_idx1] + $values[$med_idx2]) * 0.5));
	return $median;
    }
}

sub get_mod_query {
    my($struc_results,$query,$strand) = @_;
    
    # Parse out struc_results
    my @struc = split ("\t", $struc_results);
    my $loc_start = $struc[2];  ## one-based
    my $brax_len = length $struc[0];
    
    # Parse out original query
    my $chr;
    my $old_start;
    my $old_stop;
    if($query =~ /^(\S+):(\d+)-(\d+)$/) {
	$chr = $1;
	$old_start = $2;
	$old_stop = $3;
    } else {
	die "Abort:query parse error in sub-routine get_mod_query\n";
    }
    
    my $new_start;
    my $new_stop;
    my $mod_query;
    
    if($strand eq "+") {
	$new_start = $old_start + $loc_start - 1;
	$new_stop = $new_start + $brax_len - 1;
    } elsif ($strand eq "-") {
	$new_stop = $old_stop - $loc_start + 1;
	$new_start = $new_stop - $brax_len + 1;
    } else {
	die "Fatal in sub-routine get_mod_query .. strand of $strand was not recognized\n";
    }
    
    $mod_query = "$chr" . ":" . "$new_start" . "-" . "$new_stop";
	
    return $mod_query;
}

sub get_sam {
    my($bamfile,$query,$strand) = @_;
    # TEST
    #print STDERR "get_sam call received as $bamfile $query $strand for bamfile query strand\n";
    
    
    if($strand eq "+") {
	(open(SAM,"samtools view -F 0x10 $bamfile $query |")) || die "Abort: failed to open bam in sub-routine get_sam\n";
    } elsif ($strand eq "-") {
	(open(SAM,"samtools view -f 0x10 $bamfile $query |")) || die "Abort: failed to open bam in sub-routine get_sam\n";
    } else {
	return 0;
    }
    my @sam = ();
    my @fields = ();
    
    # Parse interval
    my $start;
    my $stop;
    if($query =~ /^(\S+):(\d+)-(\d+)$/) {
	$start = $2;
	$stop = $3;
    } else {
	return 0;
    }
    my $right_most;
    my $key;
    while (<SAM>) {
	chomp;
	@fields = split ("\t", $_);
	# no unmapped, just in case
	if($fields[1] & 4) {
	    next;
	}
	# left-most must be >= start and <= stop
	unless(($fields[3] >= $start) and ($fields[3] <= $stop)) {
	    next;
	}
	# right-most the same
	$right_most = $fields[3] + (length $fields[9]) - 1;
	unless(($right_most >= $start) and ($right_most <= $stop)) {
	    next;
	}
	# keeper
	push(@sam,$_);
    }
    close SAM;
    return @sam;
}

sub get_struc {
    my($seq) = @_;
    (open(FOLD, "echo $seq | RNAfold --noPS 2> /dev/null |")) || die "Abort: Failed to open RNAfold job in sub-routine get_struc.\n";
    my $seq_line = <FOLD>;
    my $brax_line = <FOLD>;
    
    # test
    #print "RNAfold output:\n$seq_line$brax_line";
    
    chomp $seq_line;
    chomp $brax_line;
    close FOLD;
    my $brax_untrimmed;
    if($brax_line =~ /^\S+/) {
	$brax_untrimmed = $&;
    } else {
	return 0;
    }
    
    # test
    #print "brax_untrimmed: $brax_untrimmed\n";
    
    # hash the structure
    my %lr = get_lr($brax_untrimmed);
    my %rl = get_rl($brax_untrimmed);
    
    my $match1;
    my $best_match1;
    my $local_offset1;
    my $best_local_offset1;
    my $brax_untrimmed1 = $brax_untrimmed;
    # find longest unclosed run of (
    while ($brax_untrimmed1 =~ /\([^\)]+/g) {
	$match1 = $&;
	$local_offset1 = (pos $brax_untrimmed1) - (length $match1);
	# trim trailing ....
	$match1 =~ s/\.+$//g;
	if($best_match1) {
	    if((length $match1) > (length $best_match1)) {
		$best_match1 = $match1;
		$best_local_offset1 = $local_offset1;
	    }
	} else {
	    $best_match1 = $match1;
	    $best_local_offset1 = $local_offset1;
	}
	
	# test
	#print "match1: $match1\nlocal_offset1:$local_offset1\nbest_match1:$best_match1\nbest_local_offset1:$best_local_offset1\n";
    }
    
    my $match2;
    my $best_match2;
    my $local_offset2;
    my $best_local_offset2;
    my $brax_untrimmed2 = $brax_untrimmed;
    # find longest unclosed run of )
    while ($brax_untrimmed2 =~ /\)[^\(]+/g) {
	$match2 = $&;
	$local_offset2 = (pos $brax_untrimmed2) - (length $match2);
	# trim trailing ....
	$match2 =~ s/\.+$//g;
	if($best_match2) {
	    if((length $match2) > (length $best_match2)) {
		$best_match2 = $match2;
		$best_local_offset2 = $local_offset2;
	    }
	} else {
	    $best_match2 = $match2;
	    $best_local_offset2 = $local_offset2;
	}
	# test
	#print "match2: $match2\nlocal_offset2:$local_offset2\nbest_match2:$best_match2\nbest_local_offset2:$best_local_offset2\n";
    }
    
    # failsafe...
    unless(($best_match2) and ($best_match1)) {
	return 0;
    }
    
    # Which one is shorter?
    my $final_offset; ## zero-based
    my $final_length;
    my $final_start; ## one-based
    my $final_stop; ## one-based
    if((length $best_match1) < (length $best_match2)) {
	$final_offset = $best_local_offset1;
	$final_start = $final_offset + 1;
	if(exists($lr{$final_start})) {
	    $final_stop = $lr{$final_start};
	} else {
	    die "FATAL in sub-routine get_struc .. failure to find final_start $final_start in hash lr\n";
	}
    } else {
	$final_stop = $best_local_offset2 + (length $best_match2);  ## converts to one-based
	if(exists($rl{$final_stop})) {
	    $final_start = $rl{$final_stop};
	} else {
	    die "FATAL in sub-routine get_struc .. failure to find final_stop $final_stop in hash rl\n";
	}
	$final_offset = $final_start - 1;  ## zero-based
    }
    $final_length = $final_stop - $final_start + 1;
    
    # trim
    my $final_brax = substr($brax_untrimmed,$final_offset,$final_length);
    # get the seq while you are at it
    my $final_seq = substr($seq_line,$final_offset,$final_length);
    # output
    my $output = "$final_brax" . "\t" . "$final_seq" . "\t" . "$final_start";
    
    # test
    #print "IN:\n\t$seq_line\n\t$brax_untrimmed\n";
    #print "OUT:\n$output\n";
    #exit;
    
    return $output;
    
    
    
}
    

sub get_sense_seq {
    my($genomefile,$query) = @_;
    (open(FASTA, "samtools faidx $genomefile $query |")) || die "Abort: Failed to get query sequence in sub-routine get_sense_seq.\n";
    my $seq;
    while (<FASTA>) {
	chomp;
	unless ($_ =~ /^>/) {
	    $seq .= "$_";
	}
    }
    close FASTA;
    my $uc_seq = uc $seq;
    # Ts to Us
    $uc_seq =~ s/T/U/g;
    return $uc_seq;
}

sub check_coordinates {
    my($co,$fai) = @_;
    my $chr;
    my $start;
    my $stop;
    if($co =~ /^(\S+):(\d+)-(\d+)$/) {
	$chr = $1;
	$start = $2;
	$stop = $3;
    } else {
	print STDERR "Abort: Coordinates $co are not formatted properly. Should be Chr:start-stop\. See documentation\.\n";
	return 0;
    }
    # start has to be less than stop, duh
    unless($start < $stop) {
	print STDERR "Abort: Coordinates $co are invalid. Start must be less than stop.\n";
	return 0;
    }
    # start has to be 1 or more, duh
    unless($start >= 1) {
	print STDERR "Abort: Coordiantes $co are invalid. Start must be 1 or greater.\n";
	return 0;
    }
    # Chr must exist in the fai, and stop must still be on the chr
    (open(FAI, "$fai")) || die "Abort: Failed to open $fai in sub-routine check_coordinates.\n";
    my @f = ();
    my $chr_end;
    while (<FAI>) {
	chomp;
	@f = split ("\t", $_);
	if($f[0] eq $chr) {
	    $chr_end = $f[1];
	    last;
	}
    }
    close FAI;
    unless($chr_end) {
	print STDERR "Abort: Chromsome $chr from query $co is not found in the genome provided.\n";
	return 0;
    }
    unless($stop <= $chr_end) {
	print STDERR "Abort: Coordinates $co are invalid. Stop is longer than the end of the chromosome.\n";
	return 0;
    }
    # No queries longer than 1kb are allowed
    if(($stop - $start + 1) > 1000) {
	print STDERR "Abort: Coordinates $co are invalid. This program does not analyze queries larger than 1kb.\n";
	return 0;
    }
    return 1;
}

sub validate_bam {
    my($bam,$fai) = @_;
    # header checks
    my %h_seqs = ();
    (open(H, "samtools view -H $bam |")) || die "Abort: Failed to open bamfile for validation\n";
    my $h;
    my $so;
    my $rgname;
    my $sq;
    while (<H>) {
	if($_ =~ /^\@/) {
	    unless($h) {
		$h = 1;
	    }
	    if($_ =~ /^\@HD\t.*SO:(\S+)/) {
		if($1 eq "coordinate") {
		    $so = 1;
		} else {
		    $so = 0;
		}
	    }
	    if($_ =~ /^\@SQ\t.*SN:(\S+)/) {
		$h_seqs{$1} = 1;
		$sq = 1;
	    }
	}
    }
    close H;
    unless($h) {
	print STDERR "Abort: Bamfile has no header. See documentation.\n";
	return 0;
    }
    unless($so) {
	print STDERR "Abort: Sort order of bamfile is not indicated as \'coordinate\' in the header. See documentation.\n";
	return 0;
    }
    unless($sq) {
	print STDERR "Abort: no SQ lines found in the bamfile header. See documentation.\n";
	return 0;
    }
    
    # does it match the genome?
    my %fai_names = ();
    (open(FAI, "$fai")) || die "Abort: Failed to open faidx file during bamfile validation\n";
    my @fields = ();
    while (<FAI>) {
	@fields = split ("\t", $_);
	$fai_names{$fields[0]} = 1;
    }
    close FAI;
    my $h_seq;
    while(($h_seq) = each %h_seqs) {
	unless(exists($fai_names{$h_seq})) {
	    print STDERR "Abort: Chromosome $h_seq was specified in bamfile but not found in genome. See documentation.\n";
	    return 0;
	}
    }
    
    # Does it have XX, XY, and XZ tags?
    (open(SAM, "samtools view $bam |")) || die "Abort: Failed to open bamfile during BAM validation.\n";
    my $check = <SAM>;
    close SAM;
    unless (($check =~ /\tXX:i:/) and ($check =~ /\tXY:Z:/) and ($check =~ /\tXZ:f:/)) {
	print STDERR "Abort: alignment data appears to lack required butter-derived custom tags. See documentation.\n";
	return 0;
    }
    
    ## Is it indexed? If not, index it.
    my $bai = "$bam" . ".bai";
    unless (-r $bai) {
	print STDERR "Expected bamfile index $bai not found. Attempting to create using samtools index ..";
	system "samtools index $bam";
	if(-r $bai) {
	    print STDERR " Done\n";
	} else {
	    print STDERR " Failed. Aborting\n";
	    return 0;
	}
    }
    
    return 1;
}

sub annotate_ps {
    my($depth_hash,$info) = @_; ## Passed by reference: hash, scalar

    # get the legend string
    my $legend_string = get_ps_legend_string($$info);
    
    # name file according to locus_name, which is the inf[4]
    my @inf = split ("\n", $$info);
    my $outfile = "$inf[4]" . ".ps";
    
    (open(PSIN, "rna.ps")) || return 0;
    (open(PSOUT, ">$outfile")) || return 0;
    while (<PSIN>) {
	## comment out drawoutline and drawpairs commands
	$_ =~ s/^drawoutline$/\% drawoutline/g;
	$_ =~ s/^drawpairs$/\% drawpairs/g;
	
	## revise bounding box comment to force a full (US) page of 8.5 inches x 11 inches
	$_ =~ s/^\%\%BoundingBox: \d+ \d+ \d+ \d+/\%\%BoundingBox: 0 0 612 792/g;
	
	## print the original
	print PSOUT "$_";
	
	## add legend information at the top
	if($_ =~ /^\%\%EndComments/) {
	    print PSOUT "$legend_string\n";
	}
        ## add the maplemark function after the init call
	if($_ =~ /^init$/) {
	    print PSOUT "\n";
	    print PSOUT "\% From maple\n";
	    print PSOUT "\/maplemark \{ \% i r g b maplemark  draw filled circle around base i\n";
	    print PSOUT "  setrgbcolor\n";
	    print PSOUT "  newpath 1 sub coor exch get aload pop\n";
	    print PSOUT "  fsize 2 div 0 360 arc closepath fill stroke\n";
	    print PSOUT "\} bind def\n";
	    
	    # also add function to mark the 5' end
	    print PSOUT "\/show5 \{ \% i mark 5-prime end at base i\n";
	    print PSOUT "  newpath 1 sub coor exch get aload pop moveto\n";
	    print PSOUT "  -5 0 rmoveto\n";
	    print PSOUT "  -15 10 rlineto\n";
	    print PSOUT "  -8 0 rmoveto \(5\'\) show stroke\n";
	    print PSOUT "\} bind def\n";
	    
	    # mark 5' end
	    print PSOUT "1 show5\n";

	    ## add the colored circles
	    my $pos;
	    my $freq;
	    my @rgb = ();
	    while(($pos,$freq) = each %$depth_hash) {
		# test
		#print STDERR "depth hash pos $pos freq $freq\n";
		@rgb = get_rgb($freq);
		print PSOUT "$pos $rgb[0] $rgb[1] $rgb[2] maplemark\n";
	    }

	}
	
    }
    close PSIN;
    close PSOUT;
    return $outfile;
}

sub get_ps_legend_string {
    my($info) = @_;  ## string delimited by new lines
    # test
    #print "Info is $info\n";

    my @inf = split ("\n", $info);
    my $string = "\% maple legend and information
0 0 1 setrgbcolor
72 720 4 0 360 arc closepath fill stroke
0 0.5 1 setrgbcolor
72 710 4 0 360 arc closepath fill stroke
0 1 1 setrgbcolor
72 700 4 0 360 arc closepath fill stroke
0.5 1 0.5 setrgbcolor
72 690 4 0 360 arc closepath fill stroke
1 1 0 setrgbcolor
72 680 4 0 360 arc closepath fill stroke
1 0.5 0 setrgbcolor
72 670 4 0 360 arc closepath fill stroke
1 0 0 setrgbcolor
72 660 4 0 360 arc closepath fill stroke
1 0 0.5 setrgbcolor
72 650 4 0 360 arc closepath fill stroke
1 0 1 setrgbcolor
72 640 4 0 360 arc closepath fill stroke

0 0 0 setrgbcolor
\/Helvetica findfont
8 scalefont
setfont
80 718 moveto
\(10\) show
\/Helvetica findfont
4 scalefont
setfont
90 722 moveto
\(0\) show

\/Helvetica findfont
8 scalefont
setfont
80 698 moveto
\(10\) show
\/Helvetica findfont
4 scalefont
setfont
90 702 moveto
\(1\) show

\/Helvetica findfont
8 scalefont
setfont
80 678 moveto
\(10\) show
\/Helvetica findfont
4 scalefont
setfont
90 682 moveto
\(2\) show

\/Helvetica findfont
8 scalefont
setfont
80 658 moveto
\(10\) show
\/Helvetica findfont
4 scalefont
setfont
90 662 moveto
\(3\) show

\/Helvetica findfont
8 scalefont
setfont
80 638 moveto
\(>=10\) show
\/Helvetica findfont
4 scalefont
setfont
99 642 moveto
\(4\) show

\/Helvetica findfont
8 scalefont
setfont
68 730 moveto
\(Depth of Coverage\) show

\% Information at bottom page.
\/Helvetica findfont
8 scalefont setfont
72 144 moveto
\(maple version $inf[0]\) show

\/Helvetica findfont
8 scalefont setfont
72 134 moveto
\(Genome: $inf[1]\) show

\/Helvetica findfont
8 scalefont setfont
72 124 moveto
\(Alignments: $inf[2]\) show

\/Helvetica findfont
8 scalefont setfont
72 114 moveto
\(Location: $inf[5] $inf[3]\) show

\/Helvetica findfont
8 scalefont setfont
72 104 moveto
\(Locus Information: $inf[4] Verdict: $inf[6] Score: $inf[7]\) show

";
    return $string;
}


sub get_rgb {
    my($freq) = @_;
    my $logfreq = (log($freq) / log(10));
    
    my @rgb = ();
    
    # First Red
    if($logfreq <= 1) {
	$rgb[0] = 0;
    } elsif (($logfreq > 1) and ($logfreq < 2)) {
	$rgb[0] = $logfreq - 1;
    } elsif ($logfreq >= 2) {
	$rgb[0] = 1;
    }
    $rgb[0] = sprintf("%.2f",$rgb[0]);
    
    # Now Green
    if($logfreq <= 1) {
	$rgb[1] = $logfreq;
    } elsif (($logfreq > 1) and ($logfreq < 2)) {
	$rgb[1] = 1;
    } elsif (($logfreq >= 2) and ($logfreq <= 3)) {
	$rgb[1] = 3 - $logfreq;
    } elsif ($logfreq > 3) {
	$rgb[1] = 0;
    }
    $rgb[1] = sprintf("%.2f",$rgb[1]);
    
    # Now Blue
    if($logfreq <= 1) {
	$rgb[2] = 1;
    } elsif (($logfreq > 1) and ($logfreq < 2)) {
	$rgb[2] = 2 - $logfreq;
    } elsif (($logfreq >= 2) and ($logfreq <= 3)) {
	$rgb[2] = 0;
    } elsif (($logfreq > 3) and ($logfreq < 4)) {
	$rgb[2] = $logfreq - 3;
    } elsif ($logfreq >= 4) {
	$rgb[2] = 1;
    }
    $rgb[2] = sprintf("%.2f",$rgb[2]);
    
    return @rgb;
}

sub get_depth_hash {
    my($read_hash) = @_; ## passed by reference
    my %dh = ();
    my @fields = ();
    my $key;
    my $freq;
    while(($key,$freq) = each %$read_hash) {
	@fields = split ("_", $key);
	for(my $i = $fields[0]; $i < ($fields[0]+ $fields[1]); ++$i) {
	    $dh{$i} += $freq;
	}
    }
    return %dh;
}

__END__

=head1 SYNOPSIS

maple: MicroRNA Analysis Program Leveraging Expression

=head1 LICENSE

maple

Copyright (C) 2014 Michael J. Axtell                                                             
                                                                                                 
This program is free software: you can redistribute it and/or modify                             
it under the terms of the GNU General Public License as published by                             
the Free Software Foundation, either version 3 of the License, or                                
(at your option) any later version.                                                              
                                                                                                 
This program is distributed in the hope that it will be useful,                                  
    but WITHOUT ANY WARRANTY; without even the implied warranty of                                   
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                    
GNU General Public License for more details.                                                     
                                                                                                 
You should have received a copy of the GNU General Public License                                
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 CITATION

As of August 25, 2014, a manuscript describing maple has been submitted and is currently under review.

=head1 AUTHOR

Michael J. Axtell, Penn State University, mja18@psu.edu

=head1 DEPENDENCIES

    perl
    samtools
    RNAfold
    RNAplot

Perl is required to be at /usr/bin/perl in order to compile maple.

samtools <http://samtools.sourceforge.net/> needs to be installed in your PATH. maple was developed using samtools 0.1.19.

RNAfold and RNAplot are from the ViennaRNA package. See <http://www.tbi.univie.ac.at/~ronny/RNA/vrna2.html>. RNAfold and RNAplot must be in your PATH. maple was developed using version 2.1.3

=head1 INSTALL

There is no real installation. Install samtools, RNAplot, and RNAfold to your PATH. For convenience, maple can also be installed to your PATH.

=head1 USAGE

maple [options] [alignments.bam] [genome.fasta] [chr:start-stop] [strand]

Output goes to STDOUT

=head1 OPTIONS

--help : Print a help message and quit

--version: Print the version number and quit

--locus_name [string] : name of locus [optional .. if not given, defaults to UserLocus]

--mature [string] : annotated/hypothesized mature miRNA sequence [optional]

--mature_name [string] : name of mature query [optional .. if --mature is given, but --mature_name is not, defaults to UserMature]

--show_duplexes [string] : What types of miR/miR* duplexes to show details for. 'all', 'pass', or 'none'. Default: 'pass'

--miRType [string] : Kingdom from which your putative MIRNA locus hails. 'animal' or 'plant'. Defaults to 'plant' 

--no_ps : Suppress creation of post-script image file

=head1 ALIGNMENTS

Alignments must be produced with the program 'butter', version 0.2.1 or higher. You should have received a copy of butter along with maple. If not, get it at https://github.com/MikeAxtell/butter

=head2 BAM file format requirements

The detailed BAM file format requirements are listed below. All of these are produced by the program 'butter', version 0.2.1 or higher.

1. The file must end with the extension ".bam"

2. The file must have a header.

3. The BAM file must be sorted by 'coordinate', as indicated by the SO: tag in the header.

4. SQ lines must be present in the header, and they must all match names found in the genome.fasta file.

5. Alignments must have custom tags XX:i, XY:Z, and XZ:f set. These tags are custom tags produced by the butter aligner program.

6. The BAM file should be indexed using samtools index. If it is not, maple will attempt to index it.

7. The BAM file must conform to the BAM/SAM format spec. 

Finally, while not a formal requirement (only because there isn't an easy way to check), maple assumes that each read is only present once in the alignment file. For multi-mapping reads, it is assumed that just one possible alignment was selected and reported. The program 'butter' accomplishes this.

=head1 PROCEDURES

After receiving a valid command, maple does the following:

=head2 Structure Identification and crude validation

The query sequence is analyzed with RNAfold. The predicted structure with the lowest predicted free energy is retained and used for further analysis. Only small RNA reads falling entirely within this structure are considered. Note that the identified structure is often smaller than the input query. If no structure at all can be recovered from the query, the locus is scored 0, and failed, and no further analysis is performed. The structure is then (crudely) validated to ensure it meets minimum criterion for a potential microRNA precursor. Specifically, the fraction of bases paired within the stem must be at least 67%, and the number of base-pairs in the helix must be at least 15. For miRType 'plant', the stem can be no longer than 150 nts, and there is no limit on the loop size. For miRType 'animal', there can be no more than 45 base-pairs in the stem, and the loop length cannot exceed 15.  Structures that don't meet these criteria are rejected, the locus is scored 0, and no further analysis performed.

=head2 Small RNA alignment retrieval

All alignments within the identified structure are retrieved. This is strand-specific, and only those alignments whose starts and stops are both within the structure are retrieved. If no alignments are found, the locus is scored 0, and failed, and no further analysis is performed.

=head2 Analysis

Analysis of expression and structural features commences provided a structure is found and there are alignments present. Details in SCORING below.

=head1 SCORING

maple identifies and scores each potential miRNA/miRNA* duplex separately. For each potential duplex, maple uses a system based on both expression and structural criteria. The final score for each duplex is equally divided between expression-based metrics and structure-based metrics, each of which account for 50% of the overall score. There are six expression-based metrics and five structure-based metrics, as detailed below. Each metric is given a score between 0 and 1 (with 0 being very poor and 1 being excellent). The six expression-based metrics are each weighted to 8.33% when calculating the overall score; the five expression-based metrics are each weighted to 10% each. The overall score thus also varies between 0 (poor) and 1 (excellent). In addition to the score, each potential miRNA/miRNA* duplex is granted a verdict of either PASS or FAIL. The PASS/FAIL decision is NOT linked directly to the score. In order to PASS, a duplex must score a certain minimum threshold on each of the criteria.  Finally, the entire locus is scored and given a PASS/FAIL verdict. The locus score is the score of the best-scoring PASS duplex, or, if no duplexes passed, the score is the best scoring FAIL duplex. A locus gets a verdict of PASS if at least one duplexed was given a PASS.

=head2 Expression-based scoring

=head3 TOTAL NUMBER OF ALIGNMENTS

This scoring component is locus-wide (it is the same for all potential miRNA/miRNA* duplexes)

Scoring matrix:

Alignments      Score

0-4             0

5-9             0.25

10-49           0.5

50-99           0.75

>=100           1

=head3 UNIQUELY ALIGNED READS

This is the number of alignments for reads that were uniquely mapped to the locus. 

This scoring component is locus-wide (it is the same for all potential miRNA/miRNA* duplexes)

Scoring matrix:

Unique_Reads  Score

0             0

>=1           1

=head3 miRNA READS

This is the number of alignments for the mature miRNA sequence

Scoring matrix

miRNA_reads  Score

0-4          0 ** causes decision of FAIL

5-9          0.25

10-49        0.5

50-99        0.75

>=100        1

=head3 STAR_READS

This is the number of alignments for the miRNA-star sequence.

Scoring matrix:

Star_reads  Score

0           0  **causes decision of FAIL

1-5         0.5

>=6         1

=head3 LENGTH OF miRNA

Scoring matrix:

Length      Score

<20         0 ** causes decision of FAIL

20,21,or 22  1

23          0.5

24          0.25

>24         0 ** causes decision of FAIL

=head3 DIVERSITY

This scoring component is locus-wide (it is the same for all potential miRNA/miRNA* duplexes)

Diversity is defined as the number of distinct alignment positions divided by the total number of alignments. This is a locus-wide parameter.  Diversity is a measure of the heterogeneity of processing. It is strongly affected by alignment depth at the locus, so maple judges the observed diversity with respect to two simulated diversity values. First, the expected diversity of the locus if alignment positions were purely random is calculated (the mean and standard deviation from 50 simulations). Second, the expected diversity of the locus if alignment positions were from a single idealized miRNA/miRNA* duplex, at a 90%/10% ratio of miRNA to miRNA* (the mean and standard deviation from 50 simulations). The observed diversity of the locus is then judged by its relationship to the purely random expectation, and the idealized expectation.

Scoring matrix:

condition a: if the idealized-mean + (2 * idealized-stdev) is >= the random-mean - (2 * random-stdev), the observed diveristy is scored 0 (** causes decision of FAIL). This occurs with low sequencing depth.

condition b: if the ideal and random diversities are far enough apart that condition a is not met, then the observed diversity value is scored as follows:

- if the observed is within 2 stdevs of the random-mean, it is scored 0 ( ** causes decision of FAIL)

- if the observed is within 2 stdevs of the ideal-mean, it is scored 1

- if the observed lies between idealized-mean + (2 * idealized-stdev) and the random-mean - (2 * random-stdev), then it is scored as 1 - (observed - (idealized-mean + (2 * idealized-stdev))). Thus values closer to the idealized mean score higher, while those closer to the random mean score lower.


=head2 Structure-based scoring

=head3 MIR_ARM

What arm of the stem is the hypothesized mature miRNA located on. For sequences that have predicted self-pairing, no arm can be determined (which causes a decision of FAIL).

Scoring matrix

Answer  Score

5p      1

3p      1

x       0 ** causes decision of FAIL

=head3 MIR_UNPAIRED

The number of nucleotides in the hypothesized mature miRNA that are unpaired.

Scoring matrix

n_unpaired  Score

0-3         1

4           0.5

5           0.25

>=6         0 ** causes decision of FAIL

=head3 STAR_COMPUTABLE

Whether or not the position of the hypothesized mature miRNA-star could be computed. Non-computable miRNA-stars indicate a highly aberrant stem-loop.

Scoring matrix

Answer  Score

Yes     1

No      0 ** causes decision of FAIL

=head3 N_BULGES_DUPLEX

The number of assymetric nucleotides in the hypothesized miRNA/miRNA-star duplex. This is calculated as the number of bulged nucleotides plus the number of 'excess' nucleotides in assymmetric internal loops. For instance, in an assymetric internal loop with 3 on one side and 2 on the other, 1 nt is in 'excess'.

Scoring matrix

n_assym Score

0-1     1

2       0.5

3       0.25

>=4     0 ** causes decision of FAIL

=head3 MAX_STEM_BUFFER

The maximum length of the stem flanking the hypothesized miRNA/miRNA-star duplex. This will either come from the loop-proximal or base-proximal side of the putative duplex. This is based on experimental and computational data indicating that plant MIRNA processing requires a spacing of about 15-17nts either from the base or the loop for the DCL enzyme to make the first 'cut' in plants. For miRType animals, the max_buffer is smaller to account for the generally ~11nts between the base of the structure and the Drosha cleavage site.

Scoring matrix - miRType 'plant'

max_buffer  Score

>=15        1

13-14       0.5

11-12       0.25

10          0.1

<=9        0 ** causes decision of FAIL

Scoring matric - miRType 'animal'

max_buffer  Score

>= 11       1

9-10        0.5

8         0.25

7           1

<=6         0  ** causes decision of FAIL

=head1 ALIGNMENTS

The text-based alignments show the sequence of the best structure and the predicted secondary structure in RNAfold dot-bracket notation. Each line under that represents a distinct read sequence. Note that the read sequences are pulled from the reference genome, not the reads themselves. In cases where read alignment allowed mismatches, this caveat becomes meaningful. 

All read lines have two values at the end. "l" represents the length of the read in nts, and "a" represents the number of alignments for that read.

=head1 DUPLEXES

By default, details of each miRNA/miRNA* duplex that had a verdict of PASS are shown. Duplexes with a verdict of FAIL are not shown by default. This can be changed with option --show_duplexes ('all' to see all of them, 'none' to see details for none of them).

=head1 ANNOTATED POST-SCRIPT IMAGES

An annotated post-script image is written to the working directory, showing the per-nucleotide read-depth along the predicted secondary structure.

=head1 NOTES

=head2 Scoring vs. the Verdict

The scores of maple are not directly linked to the "PASS" / "FAIL" decisions.  A locus can score very highly, but get a verdict of FAIL becuase it fell short in one key feature. Conversely, a locus could score lowly, but receive a verdict of PASS if it 'fails to fail' any of the key criteria.  For loci that PASS, the scores do however give some metric of confidence.

=head2 Limited judgements

Both the score and the verdict are conditional on both the hairpin structure and the expression level in the specific small RNA-seq library being examined. Therefore, it is important to note that a low score and/or a verdict of FAIL does not necessarily mean that a locus is not a MIRNA. For instance, it could be that the locus is lowly expressed in the library being considered. For more robust "blacklisting" and "whitelisting" of MIRNA annotations, loci should be queried with respect to multiple small RNA-seq libraries.

=head2 Adding flanking sequences

When using maple to analyze existing MIRNA locus annotations from miRBase, it is a good idea to add some extra flanking sequence to the queries. Many miRBase hairpin entries are rather minimal, and don't include the full extent of the structured regions at the bases of the hairpins. Entering just these too-short queries could cause otherwise acceptable loci to fail because of insufficient buffer. Therefore I suggest padding all miRBase hairpin queries by 50nts on both sides to make sure the entire structured region is captured.

=cut
